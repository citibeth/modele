#include "rundeck_opts.h"
      MODULE TES_SIMULATOR
!@sum  Routines for the Tropospheric Emission Spectrometer (TES) 
!@sum  'water simulator'
!@auth Robert Field
!@ver  1.1
C********************************************************************** 
C********************************************************************** 
C
C                   TES Water Simulator
C  
C The TES Water Simulator produces H2O and HDO vapor diagnostics 
C suitable for comparison with retrievals from the TES instrument.
C This is done by excluding model profiles that would be poorly
C retrieved by TES, and for those remaining, applying a TES operator to
C account for TES's limited vertical resolution and the contributions
C from a prior profile.
C 
C It operates in two ways:
C  
C 1) Retrieval-based: 
C    Averaging kernels are extracted directly from individual high
C    quality TES retrievals along the satellite path, and applied
C    to the model profiles. This should only be used for nudged
C    simulations. 
C
C 2) Category-based:
C    Averaging kernels are selected from 'climatogolgies', separated
C    according to cloud characteristics, surface temperature and
C    moisture. This can be used for either nudged or free-running
C    simulations. There is an option to use categorical selection
C    but with collocation, sampling the model only along the satellite
C    path.
C
C All modifications to the model code are in "#ifdef TES_SIM" 
C directives. The most important of these are:
C - the monthly ACC diagnostics definitions in DEFACC.f
C - the subdaily diagnostic definitions in SUBDD.f
C - the function calls in TRACEA of TRACER_PRT.f
C
C                   Configuration
C
C To turn it on in ModelE, configure the rundeck as follows.
C 
C Include these lines in the "Preprocessor Options":
C
C #define TRACERS_ON                  ! include tracers code
C #define TRACERS_WATER               ! water tracers
C #define TRACERS_SPECIAL_O18         ! water isotope tracers
C #define TES_SIM                     ! TES simulator
C #define CACHED_SUBDD                ! optional new-style subdaily diag.
C #define NEW_IO                      ! need this for new style subdd?
C #define NUDGE_ON                    ! optional, but often the case
C
C Include these in the "Object modules":
C
C TRACER_COM TRACERS_DRV
C TRACER
C TRDIAG_COM TRACER_PRT TRDIAG
C TRACER_O18
C TES_SIMULATOR
C NUDGE                                ! optional, as per above
C
C
C In the "Data input files:"
C      Make sure the 'ISSCP' mnemonic is set, default is presumably: 
C      ISCCP=ISCCP.tautables
C 
C      Set the mnemonic 'TES_AK', a netcdf file with categorical 
C      averaging kernel info , located in 
C      /discover/nobackup/projects/giss/prod_input_files/
C
C      A good file to use is:
C      'LndOcnCoarseISCCPTempWideCoarsePW15.Lat15.AvgKrnls.nc' 
C     
C      Also set the mnemonic 'TES_SINGLE', a netcdf file with categorical 
C      averaging kernel info for Single, normally 'Single.AvgKrnls.nc'
C       
C      Alternative files with the suffix *.AvgKrnls.nc have been placed
C      in the prod_input_files directory too. 
C      The names of the files indicate the type of categorization. 
C      The categorical variable 'bins' for a file can
C      viewed with the command 'ncdump <fileName> -v <varName>' where 
C      varName is one of:
C          srfTmpCats: surface temperature
C          optDepCats: cloud optical depth
C          cldTopPresCats: cloud top pressure
C          pwLowCats: pcp water near the surface
C          pwHighCats: pcp water in the free atmosphere
C    
C      These are generated by the MATLAB program 
C      /home/rfield1/matlab/TES/processRawTESData_***.m 
C
C  - In '&&PARAMETERS', set the following switches:
C
C      Make sure the ISCCP diagnostics are turned on with:
C          isccp_diags=1
C      
C      Optionally enable subdaily diagnostics on pressure levels. 
C      Configuration details are in SUBDD.f, but be sure to set:
C          subdd_npres: the number of pressure levels
C          subdd_pres: the pressure levels
C      Currently available are:
C          nTES: the total # of TES measurements (avg. per diagnostic period)
C          nTESGoodC: the number of good 'categorical' TES measurements
C          nTESGoodR: the numbe of good 'retrieval-based' TES measurements
C          HDORaw: the raw model HDO profiles (kg/kg)
C          H2ORaw: the raw model H2O profiles
C          HDOC: HDO profiles after applying the categorical operator
C          H2OC: H2O profiles after applying the categorical operator
C          HDOR: HDO profiles after applying the retrieval-based operator
C          H2OR: H2O profiles after applying the retrieval-based operator
C
C      TESObsDiagnosticsOn: Set to 1 to use TES diagnostics with avg
C      kernels and quality extracted directly from the measurements. 
C      
C      TESObsMinDegFr: When checking quality of TES retrievals,
C      require this minimum degrees of freedom to be included.
C      The standard TES v5 value is 1.0, was 0.5 for v4.
C
C      TESObsDataDir: Directory containing the daily TES files. On
C      discover, use:
C      '/discover/nobackup/projects/giss/OBS/TES/v5L2/out/v17/netcdf/'
C      These were also produced using 'processRawTESData_***.m'
C
C      TESCatDiagnosticsOn: Set to 1 to use TES diagnostics with 
C      avg krnls selected from categories. The simulator will use the 
C      file specified by TES_AK above.
C
C      TESCatMinQuality: Minimum % good quality data for profiles in a
C      category to be included in categorical averaging kernel 
C      selection. The categorical quality is stored in the TES_AK file
C      specified above. Those numbers are compared against this
C      threshold. 70 seemed reasonable in the past. ALTERNATIVELY, set
C      this to -9999 to randomly decide, based on the categorical quality, 
C      whether it is included. Actually, use -9999 as a default.
C
C      TESCatUseColloc: Set to 1 to use categorical avg krnl selection,
C      but only along the satellite path. This requires that 
C      all the TESObs switches above be set. Note too that the 
C      collocation here includes poor quality observations, unlike for
C      the 'TESObs' case. The quality filtering is done with 
C      TESCatMinQuality.
C
C      TESCatVariableHDOAKOnly: Set to 1 to use a single prior q 
C      profile from TES_SINGLE in the categorical operator. This 
C      overwrites the q priors and non-HDO avg krnls from whatever
C      was used in TES_AK. Just for sensitivity testing - to identify 
C      any differernces between categorizations from things other
C      than the HDO avg. krnls.
C
C                   Output
C
C The module will produce the following 'aijl' diagnostics:
C
C For categorical avg kernel selection (_CAT)
C  - H2O_QF_CAT, H2O tracer after quality filtering, no convolution
C  - HDO_QF_CAT, HDO tracer after quality filtering, no convolution
C  - H2O_TES_CAT, TES-style H2O on a truncated vertical range
C  - HDO_TES_CAT, TES-style HDO on a truncated vertical range 
C  - H2O_TES_OLD_CAT, H2O after vertical interpolation only, on 
C    truncated vertical levels
C  - HDO_TES_OLD_CAT, HDO after vertical interpolation only, on 
C    truncated vertical levels
C  - H2O_PRIOR_CAT, the selected prior H2O 
C  - Max_sens_cat, maximum HDO AK sensitivity, on truncated vert levs.
C  - Max_sens_cat_ht, height of maximum HDO AK sensitivity,
C    on truncated vert levs.
C
C For avg krnl selection directly from retrievals (_RETR)
C  - H2O_QF_RETR, H2O tracer after quality filtering, no convolution
C  - HDO_QF_RETR, H2O tracer after quality filtering, no convolution
C  - H2O_TES_RETR, TES-style H2O on a truncated vertical range 
C  - HDO_TES_RETR, TES-style HDO on a truncated vertical range 
C  - H2O_TES_OLD_RETR, H2O after vertical interpolation only, on
C        truncated vertical levels
C  - HDO_TES_OLD_RETR, HDO after vertical interpolation only, on
C        truncated vertical levels
C  - H2O_PRIOR_RETR, the prior H2O selected, for retrieval mode
C  - Max_sens_retr, maximum HDO AK sensitivity, on truncated vert levs.
C  - Max_sens_ht_retr, height of maximum HDO AK sensitivity,
C        on truncated vert levs.
C
C It will also produce the following 'aij' diagnostics:
C  - ISCCP_subgrid_ttl, total number of subgrid columns in ISCCP
C  - ISCCP_subgrid_good, number of subgrid columns with 'good' 
C        conditions for TES (i.e. those whose categorical quality 
C        in the observations is > TESCatMinQuality)
C  - TES_TGRND, ground radiative temperature
C  - TES_COD, cloud optical depth
C  - TES_CODCLDY, cloud optical depth for cloudy cells only, using
C        cod > codClrSkyThresh to identify cloudiness
C  - TES_CTP, cloud top pressure over cloudy cells only
C  - TES_PWHIGH, precipitable water in the free atmosphere
C  - TES_PWLOW, precipitable water near the surface
C  - TES_CLDY_COUNT number of cloudy subgrid colums 
C  - The '*_GOOD' versions of these are the same, but over
C    high categorical quality subgrid points only
C
C  - TES_meas_ttl, total number of actual TES measurements
C  - TES_meas_good, number of actual good TES measurements
C
C Of these, H2O_TES_CAT,HDO_TES_CAT,H2O_TES_RETR and HDO_TES_RETR are
C of primary interest. The others are for examining the effects of the 
C data quality filtering, partitioning of the effects of the
C TES operator between vertical interpolation and averaging kernel 
C convolution, and examining the variation in maximum AK sensitivity and
C the height of maximum sensitivity. These are defined in DEFACC.f.
C
C The subdaily diagnostics have the same names as specified in the rundeck.
C
C The key calculation is in 'ApplyTESAvgKrnls', based on code from
C Camille Risi.
C 
C More details can be found in: 
C Field, R.D., C. Risi, G.A. Schmidt, J. Worden, A. Voulgarakis, A.N. 
C LeGrande, A.H. Sobel, R.J. Healy, A Tropospheric Emission Spectrometer
C HDO/H2O retrieval simulator for climate models, Atmospheric Chemistry
C and Physics, 12, doi:10.5194/acp-12-10485-2012, 10485-10504, 2012.
C
C
C********************************************************************** 
C**********************************************************************


!@var ISCCPRandIndex Index of randomly chosen ISCCP subgrid column
      INTEGER,ALLOCATABLE,DIMENSION(:,:),public :: ISCCPRandIndex
!@var Arrays for  for subdaily diagnostics (Raw, C-cat, R-retr)
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:),public :: 
     &     HDORawSUBD,H2ORawSUBD,HDOCSUBD,H2OCSUBD,HDORSUBD,H2ORSUBD
!@var Counters for subdd diagnostics
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:),public :: 
     &     nTESSUBD,nTESCGoodSUBD,nTESRGoodSUBD
C**********************************************************************
C**** Variable declarations specific to categorical AK selection.
C**********************************************************************

!@var TESCatDiagnosticsOn to enable categorical averaging kernel selection
!@var TESCatUseColloc to sample only along TES path
      INTEGER, public :: TESCatDiagnosticsOn,TESCatUseColloc
!@var TESCatMinQuality minimum data quality for a TES category
!@var If set to -9999, use random quality selection
      REAL*8, public :: TESCatMinQuality
!@var TESCatVariableHDOAKOnly set to 1 to fix non-HDO components of cat. op.
      INTEGER, public :: TESCatVariableHDOAKOnly

!@var codClrSkyThresh cod threshold above which ctp's are indluded in diag.
!@var codMax in diags., cod's greater that codMax are set to codMax
      REAL*8, PARAMETER, public :: codClrSkyThresh = 0.3
      REAL*8, PARAMETER, public :: codMax = 60
C****
C**** These are read in from the TESAvgKrnlFileName file in 
C**** the subroutine ReadTESAvgKrnlFile.
C****
!@var nTESLevs number of TES pressure levels
!@var nDataLevs number of usable TES levels for HDO
!@var nAvgKrnlLevs number of avg krnl levels required for TES operator
!@var nPriorLevs number of levels in prior
!@var nsrfTmpCats number of surface temperature categories
!@var noptDepCats number of cloud optical depth categories
!@var ncldTopPresCats number of cloud top pressure categories
!@var npwLowCats number of surface precipitable water categories
!@var npwHighCats number of free atmophsere pw categories
!@var nSrfTypeCats number of surface types (should be 2: Lnd/Ocn)
      INTEGER, public :: nTESLevs,nDataLevs,nAvgKrnlLevs,nPriorLevs
      INTEGER, public :: nsrfTmpCats,noptDepCats,ncldTopPresCats
      INTEGER, public :: npwLowCats,npwHighCats
      INTEGER, public :: nSrfTypeCats

!@var TESPres 1D vector of all (67) pressure levels
!@var TESDataLevs levels in TESPres over which avg krnls are applied
!@var TESAvgKrnlLevs levels in TESPres over which avg krnls are needed
      REAL*8, ALLOCATABLE, DIMENSION(:), public :: TESPres
      INTEGER, ALLOCATABLE, DIMENSION(:), public :: TESDataLevs
      INTEGER, ALLOCATABLE, DIMENSION(:), public :: TESAvgKrnlLevs
	
!@var srfTmpCats surface temperature categories 
!@var optDepCats optical depth categories 
!@var cldTopPresCats cloud top pressure categories 
!@var pwLowCats surface precipitable watercategories 
!@var pwHighCats free atmosphere pw categories 
      REAL*8, ALLOCATABLE, DIMENSION(:), public :: srfTmpCats,optDepCats
      REAL*8, ALLOCATABLE, DIMENSION(:), public :: cldTopPresCats
      REAL*8, ALLOCATABLE, DIMENSION(:), public :: pwLowCats,pwHighCats
      REAL*8, ALLOCATABLE, DIMENSION(:), public :: srfTypeCats
!@var rPrior 1D vector of TES prior isotopic ratio
      REAL*8, ALLOCATABLE, DIMENSION(:), public :: rPrior

!@var avgKrnlH2O mean categorical H2O averaging kernels 
!@var avgKrnlHDO mean categorical HDO averaging kernels 
!@var avgKrnlHD mean categorical HD averaging kernels 
!@var avgKrnlDH mean categorical DH averaging kernels
!@var qPriors mean categorical q priors
!@var percGoodObs percent of high quality categorical TES measurements
C These arrays have one dimension for each categorical variable (6),
C one dimension for the TESDataLevs, and one for the TESAvgKrnlLevs
C The qprior array is similar, but is has one dimension on TESPres.
C percGoodObs is similar, but with no vertical dimensions.
C
C Need separate arrays for land and ocean because maximum matrix 
C rank in fortran is 7. If there's no distinction in the AK file
C (i.e. only  one land type), the 'O' matrices are used and the 'L'
C matrices are undef
C 'O' indicates for over ocean
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:,:,:),public :: 
     & avgKrnlsH2OO,avgKrnlsHDOO,avgKrnlsHDO,avgKrnlsDHO
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:,:),public :: qPriorsO
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:),public::percGoodObsO
C 'L' indicates for over land
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:,:,:),public :: 
     & avgKrnlsH2OL,avgKrnlsHDOL,avgKrnlsHDL,avgKrnlsDHL
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:,:),public :: qPriorsL
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:),public::percGoodObsL

!@var latBdy latitude boundary of TES domain
!@var bdyLyrDep boundary layer depth separating pwLow and pwHigh
      REAL*8, public:: latBdy,bdyLyrDep

C**********************************************************************
C**** Variable declarations specific to  AK selection from retrievals
C**********************************************************************

      INTEGER, public :: TESObsDiagnosticsOn
!@var TESObsDataDir location of daily TES data files
      CHARACTER(LEN=256),public ::  TESObsDataDir

!@var maxObsPerCell twice the number of TES obs in a cell ever seen
      INTEGER, PARAMETER :: maxObsPerCell =10
      INTEGER,public :: timeStrLen
      INTEGER, public :: nTESLevsPt,nDataLevsPt,nAvgKrnlLevsPt
      
!@var TESObsMinDegFr minimum deg. of freedom for a retrieval 
      REAL*8, public :: TESObsMinDegFr

!@var TESPresPt   all (67) pressure levels for each retrieval
!@var TESDataLevsPt levels in TESPres over which Avg Kernels are applied
!@var TESAvgKrnlLevsPT levels in TESPres over which Avg Kernels are used
      REAL*8, ALLOCATABLE, DIMENSION(:,:), public :: TESPresPt
      INTEGER, ALLOCATABLE, DIMENSION(:), public :: TESDataLevsPt
      INTEGER, ALLOCATABLE, DIMENSION(:), public :: TESAvgKrnlLevsPt

C****
C**** Pointwise variables, first dimension is always # of daily obs
C****
!@var avgKrnlsH2OPt H2O averaging kernels
!@var avgKrnlsHDOPt HDO averaging kernels
!@var avgKrnlsHDPt HD averaging kernels
!@var avgKrnlsDHPt DH averaging kernels
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:),public :: avgKrnlsH2OPt
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:),public :: avgKrnlsHDOPt
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:),public :: avgKrnlsHDPt
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:),public :: avgKrnlsDHPt
!@var qPriorPt q priors
!@var dDPriorPt dD priors (even though they're invariant)
      REAL*8,ALLOCATABLE,DIMENSION(:,:),public :: qPriorPt,dDPriorPt
!@var secondsPt number of seconds since midnight
      INTEGER,ALLOCATABLE,DIMENSION(:),public :: secondsPt
!@var dayTimeFlagPt day/night flag
      INTEGER,ALLOCATABLE,DIMENSION(:),public :: dayTimeFlagPt
!@var latVecPt latitude of TES measurement
!@var lonVecPt longitude of TES measurement
      REAL*8,ALLOCATABLE,DIMENSION(:),public :: latVecPt,lonVecPt
!@var latIndPt J index on model grid of measurements
!@var lonIndPt I index on model grid of measurements
      INTEGER,ALLOCATABLE,DIMENSION(:),public :: latIndPt,lonIndPt
!@var H2ODegFrPt retrieval degOfFr for H2O
!@var HDODegFrPt retrieval degOfFr for HDO
      REAL*8,ALLOCATABLE,DIMENSION(:),public :: H2ODegFrPt,HDODegFrPt
!@var H2OQualPt H2O quality flag
!@var HDOQualPt HDO quality flag
      INTEGER,ALLOCATABLE,DIMENSION(:),public :: H2OQualPt,HDOQualPt

C****
C**** Gridded variables: the point data above get mapped onto these
C****
!@var nObsGrid number of daily TES measurements on grid
      INTEGER,ALLOCATABLE,DIMENSION(:,:),public :: nObsGrid
!@var goodObFlag 1 if good quality, 0 if not
      INTEGER,ALLOCATABLE,DIMENSION(:,:,:),public:: goodObFlag
!@var secOfDayGrid seconds since midnight
      INTEGER,ALLOCATABLE,DIMENSION(:,:,:),public::
     & secOfDayGrid
!@var avgKrnlH2OGrid H2O averaging kernels mapped onto grid
!@var avgKrnlHDOGrid HDO averaging kernels mapped onto grid 
!@var avgKrnlHDGrid HD averaging kernels mapped onto grid 
!@var avgKrnlDHGrid DH averaging kernels mapped onto grid
C The dimensions here are I,J,nObs,nDataLev,nAvgKrnlLev
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:),public::
     & avgKrnlsH2OGrid
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:),public::
     & avgKrnlsHDOGrid
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:),public::
     & avgKrnlsHDGrid
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:,:),public::
     & avgKrnlsDHGrid
!@var qPriorsGrid q priors mapped onto grid
!@var dDPriorsGrid dD priors mapped onto grid (invariant)
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:),public::
     & qPriorsGrid
      REAL*8,ALLOCATABLE,DIMENSION(:,:,:,:),public::
     & dDPriorsGrid

      END MODULE TES_SIM

C********************************************************************** 
C********************************************************************** 
C
C                   GISS ModelE-specific routines
C
C********************************************************************** 
C**********************************************************************

      SUBROUTINE ApplyTESOpCategoricalAK(J_0,J_1,I_0,I_1)	  
C********************************************************************** 
C Description: This applies the categorical TES operator to H2O and 
C HDO model profiles. It is currently called in TRACEA, but in theory
C could appear anywhere after the model physics is completed.
C
C This is done only within a latitude boundary defined by latBdy 
C and during daytime, for compatibility with the ISCCP simulator.
C The steps are to:
C    - convert profiles to vmr from mass-mixing ratio
C    - calculate the surface radiative temperature with fractional
C      contributions from the different surface types
C    - calculate preciptable water near surface and in free atmosphere
C    - for a randomly chosen ISCCP subgrid column, 
C       - retrieve the COD and CTP
C  	- along with tsurf and low/high precip water, fetch the 
C         observed % retrieval quality for that category, randomly
C         decide whether the model profile would be well-retrieved 
C   	- if yes, fetch the appropriate averaging kernels and
C         q prior, apply TES operator and accumulate diagnostics
C
C Note that acc TES diagnostics have been defined in the aijl arrays, 
C rather than the taijl arrays. The taijl arrays would be a more 
C logical place, but don't have 'denom' arrays and so don't allow
C for conditional accumulation.
C
C To-do: bury all of the diagnostic stuff in a subroutine.
C********************************************************************** 
      USE CONSTANT, only : undef	  
      USE DYNAMICS, only: pmid,am
      USE GEOM, only: axyp,LAT_DG,LON_DG,IMAXJ
      USE MODEL_COM, only: im,jm,lm ,q,focean,flice,
     *                     JDAY,JMON,JDATE,JYEAR,JHOUR,
     *                     itime,nday,ItimeI,IYEAR1,JDPERY,
     *                     NDAY,DTSrc
      USE SEAICE_COM, only : rsi
      USE LAKES_COM, only : flake
      USE GHY_COM, only : fearth
      USE FLUXES, only : GTEMP,GTEMPR
      USE CLOUDS_COM, only: ncol
      USE RANDOM
 
      USE TRACER_COM, only : trm,n_HDO,n_water
      USE DIAG_COM, only: aijl=>aijl_loc, aij=>aij_loc
     *     ,IJL_DP_QF,IJL_H2O_QF,IJL_HDO_QF
     *     ,IJL_DP_TES,IJL_H2O_TES,IJL_HDO_TES
     *     ,IJL_H2O_TES_OLD,IJL_HDO_TES_OLD
     *     ,IJL_H2O_PRIOR
     *     ,IJL_TES_SEN,IJL_TES_SEN_HT
     *     ,IJ_TES_SUNL
     *     ,IJ_TES_TTL,IJ_TES_GOOD,IJ_TES_TTL_CLDY_GOOD
     *     ,IJ_TES_TGRND,IJ_TES_TGRND_GOOD
     *     ,IJ_TES_PWL,IJ_TES_PWL_GOOD
     *     ,IJ_TES_PWH,IJ_TES_PWH_GOOD
     *     ,IJ_TES_CTP,IJ_TES_CTP_GOOD
     *     ,IJ_TES_COD,IJ_TES_COD_GOOD
     *     ,IJ_TES_CODCLDY,IJ_TES_CODCLDY_GOOD
     *     ,IJ_TES_TTL_CLDY
     *     ,saveSCLDI
     *     ,saveBOXTAU, saveBOXCTP
     *     ,scale_ijl
      USE TES_SIMULATOR
      
      IMPLICIT NONE      
C***** INPUT VARIABLES
      INTEGER,INTENT(IN) :: I_0,I_1,J_0,J_1

C**** INTERNAL VARIABLES
      REAL*8, DIMENSION(nTESLevs) ::currQPrior
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKH2O
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKHDO
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKHD
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKDH
      REAL*8, DIMENSION(lm) :: h2oModelSH,hdoModelSH
      REAL*8, DIMENSION(lm) :: h2oModelNewSH,hdoModelNewSH
      REAL*8, DIMENSION(lm) :: h2oModelIntpSH,hdoModelIntpSH
      REAL*8, DIMENSION(lm) :: qPriorModLev
      INTEGER :: code,currCol,I,J,L
      REAL*8,DIMENSION(lm) :: dDOld
      REAL*8,DIMENSION(lm) :: dDNew
      REAL*8 POICE,PEARTH,PLANDI,POCEAN,currTgrnd
      REAL*8 :: pcpWLow,pcpWHigh
      REAL*8 :: currCOD, currCTP
      INTEGER :: currSec,currSecITU,minSecITU,maxSecITU
      INTEGER :: currQualFlag,collocOK
      INTEGER :: overOcean,srfTypeI,tgrndI,pwLowI,pwHighI,codI,ctpI
      REAL*8 :: currPercGood,currNObs,currOb
      REAL*8,DIMENSION(lm) :: maxSen,maxSenHt
      REAL*8, DIMENSION(nAvgKrnlLevs) :: AKrow
      REAL*8, DIMENSION(I_0:I_1,J_0:J_1) :: randQualArray
      REAL*8 currRandQual,xx
      INTEGER randISCCPCol,goodProfile,oldSeed
      integer :: nij_before_j0,nij_after_j1,nij_after_i1


C**** 
C**** Set up 2D array of random numbers over local domain.
C**** This is required for probability-based profile quality filtering.
C**** RINIT and RFINAL are called so that these calls don't affect 
C**** prognostic quantities that use RANDU.
C**** 

C     Save current random number seed
      CALL RFINAL(oldSeed)

C     Create random number array
      CALL BURN_RANDOM(nij_before_j0(J_0))
      DO J=J_0,J_1
          CALL BURN_RANDOM((I_0-1))
          DO I=I_0,I_1
              randQualArray(I,J) = RANDU(xx)
          END DO
          CALL BURN_RANDOM(nij_after_i1(I_1))
      END DO
      CALL BURN_RANDOM(nij_after_j1(J_1))

C     Restore old random number seeed
      CALL RINIT(oldSeed)

C**** Loop over local domain
      do j=J_0,J_1
          do i=I_0,I_1

#ifdef CACHED_SUBDD
C****         Store raw H2O and HDO profiles for SUBDD
              do L=1,LM
                  H2ORawSUBD(i,j,l) = q(i,j,l)
                  HDORawSUBD(i,j,l) = trm(i,j,l,n_HDO)/
     *                (am(l,i,j)*axyp(i,j))
              enddo
#endif
C****         Option to continue only if there was a good 
C****         TES measurement during the current time. We don't care
C****         about the actual AKs, just whether the satellite was 
C****         there.
              collocOK = 1
              IF (TESCatUseColloc.eq.1) THEN
              collocOK = 0
              if (ALLOCATED(nObsGrid)) then
                  currNObs = nObsGrid(I,J)
                  if (currNObs .gt. 0) then

C****             See if any of the measurements in the cell occurred
C****             during the current time step. Unlike
C****             ApplyTESOpRetrievalAK, there's no check on the 
C****             measurement quality - that's part of what we're
C****             tring to model with the categories.
C****             This could be done as a separate pre-processing step
C****             and the results shared with 'ApplyTESOpRetrievalAK'?
                  do currOb=1,currNObs

C****                 Convert seconds-since-00z of measurement to
C****                 model's internal time units
                      currSec= secOfDayGrid(i,j,currOb)
                      currSecITU = (JYEAR-IYEAR1)*JDPERY + JDAY-1
                      currSecITU = currSecITU*NDay*DTSrc
                      currSecITU = currSecITU + currSec
                      
C****                 The current time range of interest
                      minSecITU=ITIME*DTSrc
                      maxSecITU=(ITIME+1)*DTSrc

                      if (currSecITU >= minSecITU .and.
     &                    currSecITU < maxSecITU) then
                          collocOK = 1
                      end if
                  enddo
                  end if
              end if
              END IF

C****         Analysis is restricted to region within latBdy 
C****         (defined in AK files, for now tropical) during daytime
              if (ABS(LAT_DG(j,1)).le.latBdy .and.
     &            saveSCLDI(i,j).eq.1 .and. 
     &             collocOK.eq.1) then

                  aij(i,j,IJ_TES_SUNL) = aij(i,j,IJ_TES_SUNL) + 1.               

C****             Retrieve model profiles of H2O and HDO moist mmr 
C****             (i.e. specific humidity)
                  do L=1,LM
C****                 Use of prognostic q or passive trm water produce
C****                 identical results. So does including water
C****                 in denominator of h2o and hdo mmr.
                      h2oModelSH(l)=q(i,j,l)
                      hdoModelSH(l)=trm(i,j,l,n_HDO)/
     *                         (am(l,i,j)*axyp(i,j))
C     *                         (trm(i,j,l,n_Water)
C     *                         + am(l,i,j)*axyp(i,j))
                  enddo

C****             Compute ground radiative temp as in DIAG.f around
C****             L1863 - could just save retrieve that value, 
C****             rather than recalculate.
                  POCEAN=(1.-RSI(I,J))*(FOCEAN(I,J)+FLAKE(I,J))
                  POICE=RSI(I,J)*(FOCEAN(I,J)+FLAKE(I,J))
                  PEARTH=FEARTH(I,J)
                  PLANDI=FLICE(I,J)
                  currTgrnd=
     *                POCEAN*GTEMPR(1,I,J)+
     *                POICE*GTEMPR(2,I,J)+
     *                PLANDI*GTEMPR(3,I,J)+
     *                PEARTH*GTEMPR(4,I,J)

C****             Determine if land or ocean, based on 50% coverage
                  overOcean = 1
                  IF (PLANDI+PEARTH.gt.0.5) THEN
                      overOcean = 0
                  ENDIF

C****             Calculate precipitable water near surface and in 
C****             free atm.
                  CALL CalcPcpWat(lm,pmid(:,i,j),h2oModelSH,
     &                bdyLyrDep,pcpWLow,pcpWHigh)

C****             Fetch the randomly selected ISCCP subgrid column and
C****             cod/ctp. Might not even need this due to 
C****             randomization within ISSCP?
                  randISCCPCol = ISCCPRandIndex(i,j)
                  currCOD = saveBOXTAU(i,j,randISCCPCol)
                  currCTP = saveBOXCTP(i,j,randISCCPCol)
                  
C****             Probably don't need this counter in addition to
C****             SUNL anymore - was just for multiple subgrid cols.
                  aij(i,j,IJ_TES_TTL)=aij(i,j,IJ_TES_TTL)+1.

C****             Accumulate grid-scale categorical variables
                  aij(i,j,IJ_TES_TGRND) = aij(i,j,IJ_TES_TGRND)
     &               + currTgrnd    
                  aij(i,j,IJ_TES_PWL) = aij(i,j,IJ_TES_PWL) 
     &               + pcpWLow
                  aij(i,j,IJ_TES_PWH) = aij(i,j,IJ_TES_PWH)
     &               + pcpWHigh
                      
C****             For consisency with observations, where bizarrely high
C****             values are set to this maximum.
                  IF (currCOD.gt.codMax) THEN
                      currCOD = codMax
                  END IF
                  aij(i,j,IJ_TES_COD) = aij(i,j,IJ_TES_COD) + 
     &                currCOD
                  IF (currCOD .gt. codClrSkyThresh) THEN
                      aij(i,j,IJ_TES_TTL_CLDY)=
     &                    aij(i,j,IJ_TES_TTL_CLDY) + 1.
                      aij(i,j,IJ_TES_CTP) = aij(i,j,IJ_TES_CTP) +
     &                    currCTP
                      aij(i,j,IJ_TES_CODCLDY) = 
     &                    aij(i,j,IJ_TES_CODCLDY) + currCOD
                  END IF

C****             Retrieve the categorical indices corresponding 
C****             to current cod,ctp,tsurf, and pw values.
                  CALL RetrieveAKIndices(currCOD,currCTP,currTgrnd
     *                 ,pcpWLow,pcpWHigh
     *                 ,noptDepCats,ncldTopPresCats,nsrfTmpCats
     *                 ,npwLowCats,npwHighCats
     *                 ,optDepCats,cldTopPresCats,srfTmpCats
     *                 ,pwLowCats,pwHighCats	 
     *                 ,codI,ctpI,tgrndI
     *                 ,pwLowI,pwHighI)

C****             We're only interested in categories for which 
C****             TES measurements are of some sufficient quality.
C****             This attempts to model the sensitivity thresholds
C****             and quality flags used to filter the TES data.
                  IF (overOcean) THEN
                      currPercGood = percGoodObsO(tgrndI,codI
     *                 ,ctpI,pwLowI,pwHighI)
                  ELSE
                      currPercGood = percGoodObsL(tgrndI,codI
     *                 ,ctpI,pwLowI,pwHighI)
                  END IF

C****             Decide whether to include profile in one of two
C****             ways: 1) randomly decide based on the categorical
C****             quality 2) use the predefined TESCatMinQuality
C****             threshold.
                  goodProfile =0
                  IF (TESCatMinQuality.lt.0) THEN
                      currRandQual = 100.*randQualArray(I,J)
                      IF (currRandQual.le.currPercGood .and.
     &                    currPercGood.gt.0) THEN
                          goodProfile=1
                      ENDIF
                  ELSE
                      IF (currPercGood .gt. TESCatMinQuality) THEN
                          goodProfile=1
                      ENDIF
                  END IF

                  if (goodProfile.eq.1) then
C****                 Store un-modified profiles to accumulation 
C****                 diagnostics, for comparison
                      do L=1,LM 
                      aijl(i,j,L,IJL_H2O_QF)=
     *                     aijl(i,j,L,IJL_H2O_QF)+
     *                     h2oModelSH(l)
                      aijl(i,j,L,IJL_HDO_QF)=
     *                     aijl(i,j,L,IJL_HDO_QF)+
     *                     hdoModelSH(l)
                      aijl(i,j,L,IJL_DP_QF)=
     *                     aijl(i,j,L,IJL_DP_QF) + 1.
                      enddo

C****                 Accumulate categorical variable diagnostics 
C****                 for 'good' retrievals
                      aij(i,j,IJ_TES_GOOD)=aij(i,j,IJ_TES_GOOD)+1.
                      aij(i,j,IJ_TES_TGRND_GOOD) = 
     &                    aij(i,j,IJ_TES_TGRND_GOOD) + currTgrnd
                      aij(i,j,IJ_TES_PWL_GOOD) = 
     &                    aij(i,j,IJ_TES_PWL_GOOD) + pcpWLow
                      aij(i,j,IJ_TES_PWH_GOOD) = 
     &                    aij(i,j,IJ_TES_PWH_GOOD) + pcpWHigh

C****                'Good' and cloudy
                      aij(i,j,IJ_TES_COD_GOOD) = 
     &                   aij(i,j,IJ_TES_COD_GOOD) + currCOD
                      IF (currCOD .gt. codClrSkyThresh) THEN
                          aij(i,j,IJ_TES_TTL_CLDY_GOOD)=
     &                        aij(i,j,IJ_TES_TTL_CLDY_GOOD) + 1.
                          aij(i,j,IJ_TES_CTP_GOOD) = 
     &                        aij(i,j,IJ_TES_CTP_GOOD) + currCTP
                          aij(i,j,IJ_TES_CODCLDY_GOOD) = 
     &                        aij(i,j,IJ_TES_CODCLDY_GOOD)+currCOD
                      END IF

C****                 Retrieve AKs and Q prior for current set of 
C****                 indices
                      IF (overOcean) THEN
	              currAKH2O = avgKrnlsH2OO(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
	              currAKHDO = avgKrnlsHDOO(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
	              currAKHD = avgKrnlsHDO(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
	              currAKDH = avgKrnlsDHO(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
                      currQPrior = qPriorsO(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:)
                      ELSE
	              currAKH2O = avgKrnlsH2OL(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
	              currAKHDO = avgKrnlsHDOL(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
	              currAKHD = avgKrnlsHDL(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
	              currAKDH = avgKrnlsDHL(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:,:)
                      currQPrior = qPriorsL(tgrndI,
     &                            codI,ctpI,pwLowI,pwHighI,:)
                      ENDIF

C****                 Apply the TES operator to profiles with 
C****                 current AKs and prior
                      CALL ApplyTESOperator(nTESLevs,TESPres
     &                    ,h2oModelSH,hdoModelSH,pmid(:,i,j)
     &                    ,currQPrior,rPrior
     &                    ,nDataLevs,nAvgKrnlLevs
     &                    ,TESDataLevs,TESAvgKrnlLevs
     &                    ,currAKH2O,currAKHDO
     &                    ,currAKHD,currAKDH
     &                    ,h2oModelNewSH,hdoModelNewSH
     &                    ,h2oModelIntpSH,hdoModelIntpSH
     &                    ,qPriorModLev,maxSen,maxSenHt)

C****                 For debugging....
                      IF (LAT_DG(j,1).eq.-9999) THEN
                         print *,''
                         print *,''
                         print *,''
                         print *,'JDATE',JDATE
                         print *,'JHOUR',JHOUR
                         print *,'lat: ',LAT_DG(j,1)
                         print *,'lon: ',LON_DG(I,1)
                         print *,'pmid(:,i,j)',pmid(:,i,j)
                         print *,'currAKH2O',currAKH2O
                         print *,''
                         print *,'currAKHD',currAKHD
                         print *,''
                         print *,'currAKDH',currAKDH
                         print *,''
                      END IF

C****                 For debugging
C*                      dDNew=1000*(hdoModelNewSH/
C*     &                  (h2oModelNewSH*0.000329) - 1)

C****                 Accumulate new convolved profiles, and
C****                 associated diagnostics. The range of
C****                 valid values is limited by nDataLevs,so need
C****                 to check for undefs in the new profiles.
                      do L=1,LM 
                      if (h2oModelNewSH(L).ne.undef
     &                  .and. hdoModelNewSH(L).ne.undef
     &                  .and. qPriorModLev(L).ne.undef) then
                        aijl(i,j,L,IJL_H2O_TES)=
     *                    aijl(i,j,L,IJL_H2O_TES)+h2oModelNewSH(L)
                        aijl(i,j,L,IJL_HDO_TES)=
     *                    aijl(i,j,L,IJL_HDO_TES)+hdoModelNewSH(L)
                        aijl(i,j,L,IJL_H2O_TES_OLD)=
     *                    aijl(i,j,L,IJL_H2O_TES_OLD)
     *                    + h2oModelIntpSH(L)
                        aijl(i,j,L,IJL_HDO_TES_OLD)=
     *                    aijl(i,j,L,IJL_HDO_TES_OLD)
     *                    + hdoModelIntpSH(L)
                        aijl(i,j,L,IJL_H2O_PRIOR)=
     *                    aijl(i,j,L,IJL_H2O_PRIOR)
     *                    + qPriorModLev(L)
    	                aijl(i,j,L,IJL_DP_TES)=
     *                    aijl(i,j,L,IJL_DP_TES) + 1.

#ifdef CACHED_SUBDD
                        HDOCSUBD(i,j,L) = hdoModelNewSH(L)
                        H2OCSUBD(i,j,L) = h2oModelNewSH(L)
                        nTESCGoodSUBD(i,j,L) = 
     &                      nTESCGoodSUBD(i,j,L)+1.
#endif
                      endif
                      if (maxSen(L).ne.undef 
     &                   .and. maxSenHt(L).ne.undef) then
                          aijl(i,j,L,IJL_TES_SEN) = 
     *                      aijl(i,j,L,IJL_TES_SEN) + maxSen(L)
                          aijl(i,j,L,IJL_TES_SEN_HT) = 
     *                      aijl(i,j,L,IJL_TES_SEN_HT) + maxSenHt(L)
                      endif 
                      enddo
                  endif
              endif				   
          enddo
      enddo

      END SUBROUTINE ApplyTESOpCategoricalAK

      SUBROUTINE ApplyTESOpRetrievalAK(J_0,J_1,I_0,I_1)
C**********************************************************************
C Description: For each cell populated with TES observations,
C apply the AKs and priors from the actual, individual retrievals to
C the modeled profile, store in diagnostic arrays.
C
C Specifically:
C    For each (i,j) on the local grid
C        - If the averaging kernel count at (i,j) >=1 
C            - Extract the model's H2O and HDO profiles from (i,j)
C            - Convert from model levels to TES pressure levels
C            - Do any necessary unit conversions
C            - For each good TES observation in that cell
C                - apply the avg krnls to the modeled
C                  H2O and HDO profiles
C                - convert back to mmr, model levels
C                - accumulate the new profiles
C**********************************************************************

      USE CONSTANT, only : undef	  
      USE DYNAMICS, only: pmid,am
      USE GEOM, only: axyp,LAT_DG,LON_DG
      USE MODEL_COM, only: im,jm,lm,q,JDAY,JMON,JDATE,JYEAR,JHOUR,
     *                     itime,nday,ItimeI,IYEAR1,JDPERY,
     *                     NDAY,DTSrc,
     *                     focean,flice
      USE DOMAIN_DECOMP_1D, only: am_i_root
      USE TRACER_COM, only : trm,n_HDO,n_water
      USE DIAG_COM, only: aijl=>aijl_loc, aij=>aij_loc
     *     ,IJL_DP_QF_R,IJL_H2O_QF_R,IJL_HDO_QF_R
     *     ,IJL_DP_TES_R,IJL_H2O_TES_R,IJL_HDO_TES_R
     *     ,IJL_H2O_TES_OLD_R,IJL_HDO_TES_OLD_R
     *     ,IJL_H2O_PRIOR_R
     *     ,IJL_TES_SEN_R,IJL_TES_SEN_HT_R
     *     ,IJ_TES_TTL_R
     *     ,IJ_TES_GOOD_R,IJ_TES_CLDY_GOOD_R
     *     ,IJ_TES_TGRND_GOOD_R
     *     ,IJ_TES_PWL_GOOD_R
     *     ,IJ_TES_PWH_GOOD_R
     *     ,IJ_TES_CTP_GOOD_R
     *     ,IJ_TES_COD_GOOD_R
     *     ,IJ_TES_CODCLDY_GOOD_R
     *     ,scale_ijl
     *     ,saveSCLDI
     *     ,saveBOXTAU, saveBOXCTP
      USE TES_SIMULATOR
      USE SEAICE_COM, only : rsi
      USE LAKES_COM, only : flake
      USE GHY_COM, only : fearth
      USE FLUXES, only : GTEMP,GTEMPR
      USE CLOUDS_COM, only: ncol
      
      IMPLICIT NONE      
C***** INPUT VARIABLES
!@var I_0,I_1,J_0,J_1 current array bounds
      INTEGER,INTENT(IN) :: I_0,I_1,J_0,J_1

C**** INTERNAL VARIABLES
      REAL*8, DIMENSION(nTESLevs) ::currQPrior
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKH2O
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKHDO
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKHD
      REAL*8, DIMENSION(nDataLevs,nAvgKrnlLevs) :: currAKDH
      REAL*8, DIMENSION(lm) :: h2oModelSH,hdoModelSH
      REAL*8, DIMENSION(lm) :: h2oModelNewSH,hdoModelNewSH
      REAL*8, DIMENSION(lm) :: h2oModelIntpSH,hdoModelIntpSH
      REAL*8, DIMENSION(lm) :: qPriorModLev
      INTEGER :: code,currNObs,currOb,I,J,L,currQualFlag
      INTEGER :: currSec,currSecITU,minSecITU,maxSecITU
      REAL*8,DIMENSION(lm) :: dDOld
      REAL*8,DIMENSION(lm) :: dDNew
      REAL*8,DIMENSION(lm) :: maxSen,maxSenHt
      REAL*8 :: currHourFrac
      REAL*8 POICE,PEARTH,PLANDI,POCEAN,currTgrnd
      REAL*8 :: pcpWLow,pcpWHigh
      REAL*8 :: currCOD, currCTP
      LOGICAL :: isNanSens
      INTEGER randISCCPCol


      IF (ALLOCATED(nObsGrid)) THEN
      do j=J_0,J_1
          do i=I_0,I_1

C****         For consistency with categorical AK selection, works only
C****         during the day.
              if (ABS(LAT_DG(j,1)).le.latBdy
     &        .and.saveSCLDI(i,j).eq.1) then

C****         Look for grid cells with measurements during
C****         current day
              currNObs = nObsGrid(I,J)
              
              if (currNObs.ge.1) then
C****             Retrieve profiles of H2O and HDO moist
C****             mmr (i.e. specific humidity)
                  do L=1,LM
C****                 Use of prognostic q or passive trm water produce
C****                 identical results. So does including water in
C****                 denominator of h2o and hdo mmr.
                      h2oModelSH(l)=q(i,j,l)
                      hdoModelSH(l)=trm(i,j,l,n_HDO)/
     *                         (am(l,i,j)*axyp(i,j))
C     *                         (trm(i,j,l,n_Water)
C     *                         + am(l,i,j)*axyp(i,j))
                  enddo

                  dDOld=1000*(hdoModelSH/
     &                  (h2oModelSH*0.000329) - 1)

C****             For each good TES measurement during the current
C****             time step, apply its AK and prior in the
C****             convolution, accumulating the results.
                  do currOb=1,currNObs

C****                 Convert seconds-since-00z of measurement to
C****                 model's internal time units
                      currSec= secOfDayGrid(i,j,currOb)
                      currSecITU = (JYEAR-IYEAR1)*JDPERY + JDAY-1
                      currSecITU = currSecITU*NDay*DTSrc
                      currSecITU = currSecITU + currSec
                      
C****                 The current time range of interest
                      minSecITU=ITIME*DTSrc
                      maxSecITU=(ITIME+1)*DTSrc

                      currQualFlag = goodObFlag(i,j,currOb)

C****                 This should really nested in the next if 
C****                 statement
                      if (currSecITU >= minSecITU .and.
     &                    currSecITU < maxSecITU) then
                      aij(i,j,IJ_TES_TTL_R)=
     &                    aij(i,j,IJ_TES_TTL_R)+1.
                      end if

                      if (currSecITU >= minSecITU .and.
     &                    currSecITU < maxSecITU .and.
     &                    currQualFlag .eq. 1) then
                      aij(i,j,IJ_TES_GOOD_R)=
     &                    aij(i,j,IJ_TES_GOOD_R)+1.

C****                 Store un-modified profiles to accumulation 
C****                 diagnostics, for comparison
                      do L=1,LM 
                      aijl(i,j,L,IJL_H2O_QF_R)=
     *                     aijl(i,j,L,IJL_H2O_QF_R)+
     *                     h2oModelSH(l)
                      aijl(i,j,L,IJL_HDO_QF_R)=
     *                     aijl(i,j,L,IJL_HDO_QF_R)+
     *                     hdoModelSH(l)
                      aijl(i,j,L,IJL_DP_QF_R)=
     *                     aijl(i,j,L,IJL_DP_QF_R) + 1.
                      enddo
C****                 Retrieve underlying variables used for categorical
C****                 operator. They're not being used, but need to be 
C****                 diagnosed for the retrieval-based 'good' points.

C****                 Compute ground radiative temp as in DIAG.f around
C****                 L1863 - should just save retrieve that value, 
C****                 rather than recalculate.
                      POCEAN=(1.-RSI(I,J))*(FOCEAN(I,J)+FLAKE(I,J))
                      POICE=RSI(I,J)*(FOCEAN(I,J)+FLAKE(I,J))
                      PEARTH=FEARTH(I,J)
                      PLANDI=FLICE(I,J)
                      currTgrnd=
     *                    POCEAN*GTEMPR(1,I,J)+
     *                    POICE*GTEMPR(2,I,J)+
     *                    PLANDI*GTEMPR(3,I,J)+
     *                    PEARTH*GTEMPR(4,I,J)

                      CALL CalcPcpWat(lm,pmid(:,i,j),h2oModelSH,
     &                    bdyLyrDep,pcpWLow,pcpWHigh)

                      randISCCPCol = ISCCPRandIndex(i,j)
                      currCOD = saveBOXTAU(i,j,randISCCPCol)
                      currCTP = saveBOXCTP(i,j,randISCCPCol)

C****                 Accumulate diagnostics from 'good' points,
C****                 according to individual retrievals
                      aij(i,j,IJ_TES_TGRND_GOOD_R) = 
     &                    aij(i,j,IJ_TES_TGRND_GOOD_R) + currTgrnd
                      aij(i,j,IJ_TES_PWL_GOOD_R) = 
     &                    aij(i,j,IJ_TES_PWL_GOOD_R) + pcpWLow
                      aij(i,j,IJ_TES_PWH_GOOD_R) = 
     &                    aij(i,j,IJ_TES_PWH_GOOD_R) + pcpWHigh

C****                'Good' and cloudy
                      aij(i,j,IJ_TES_COD_GOOD_R) = 
     &                   aij(i,j,IJ_TES_COD_GOOD_R) + currCOD
                      IF (currCOD .gt. codClrSkyThresh) THEN
                          aij(i,j,IJ_TES_CLDY_GOOD_R)=
     &                        aij(i,j,IJ_TES_CLDY_GOOD_R) + 1.
                          aij(i,j,IJ_TES_CTP_GOOD_R) = 
     &                        aij(i,j,IJ_TES_CTP_GOOD_R) + currCTP
                          aij(i,j,IJ_TES_CODCLDY_GOOD_R) = 
     &                        aij(i,j,IJ_TES_CODCLDY_GOOD_R)+currCOD
                      END IF
                      

C****                 Retrieve AKs and Q prior for current observation
	              currAKH2O = avgKrnlsH2OGrid(i,j,currOb,:,:)
	              currAKHDO = avgKrnlsHDOGrid(i,j,currOb,:,:)
	              currAKHD = avgKrnlsHDGrid(i,j,currOb,:,:)
	              currAKDH = avgKrnlsDHGrid(i,j,currOb,:,:)
	              currQPrior = qPriorsGrid(i,j,currOb,:)

C                     Should really get rPrior from individual measurements, rather
C                     than relying on categorical averaging kernel file. They're
C                     identical, but the categorical avg krnl file might not 
C                     always be used. 

C****                 Apply the TES operator to profiles with current
C****                 AKs and prior
                      CALL ApplyTESOperator(nTESLevs,TESPres
     &                        ,h2oModelSH,hdoModelSH,pmid(:,i,j)
     &                        ,currQPrior,rPrior
     &                        ,nDataLevs,nAvgKrnlLevs
     &                        ,TESDataLevs,TESAvgKrnlLevs
     &                        ,currAKH2O,currAKHDO
     &                        ,currAKHD,currAKDH
     &                        ,h2oModelNewSH,hdoModelNewSH
     &                        ,h2oModelIntpSH,hdoModelIntpSH
     &                        ,qPriorModLev,maxSen,maxSenHt)

C                          dDNew=1000*(hdoModelNewSH/
C     &                          (h2oModelNewSH*0.000329) - 1)
C                     Option to print single profiles before and
C                     after TES operator, for illustrations
                      IF (LAT_DG(j,1).eq.-9999) THEN
                          print *,''
                          print *,''
                          print *,''
                          print *,'JDATE',JDATE
                          print *,'JHOUR',JHOUR
                          print *,'lat: ',LAT_DG(j,1)
                          print *,'lon: ',LON_DG(I,1)
                          print *,'pmid(:,i,j)',pmid(:,i,j)
C                          print *,'dDOld'
C                          print *, dDOld
C                          print *,'dDNew'
C                          print *, dDNew
C                          print *,'h2oModelSH'
C                          print *,h2oModelSH
                          print *,'currQPrior',currQPrior
                          print *,'qPriorModLevRetr',qPriorModLev
                          print *,''
                          print *,''
                          print *,''
                      END IF

C****                 Accumulate new convolved profiles, and
C****                 associated diagnostics. The range of valid
C****                 values is limited by nDataLevs, so need to check
C****                 for undefs in the new profiles.
                      do L=1,LM 
                      if (h2oModelNewSH(L).ne.undef
     &                  .and. hdoModelNewSH(L).ne.undef) then
                        aijl(i,j,L,IJL_H2O_TES_R)=
     *                    aijl(i,j,L,IJL_H2O_TES_R)
     *                    +h2oModelNewSH(L)

                        aijl(i,j,L,IJL_HDO_TES_R)=
     *                    aijl(i,j,L,IJL_HDO_TES_R)
     *                    +hdoModelNewSH(L)

                        aijl(i,j,L,IJL_H2O_TES_OLD_R)=
     *                    aijl(i,j,L,IJL_H2O_TES_OLD_R)
     *                    + h2oModelIntpSH(L)

                        aijl(i,j,L,IJL_HDO_TES_OLD_R)=
     *                    aijl(i,j,L,IJL_HDO_TES_OLD_R)
     *                    + hdoModelIntpSH(L)

                        aijl(i,j,L,IJL_H2O_PRIOR_R)=
     *                    aijl(i,j,L,IJL_H2O_PRIOR_R)
     *                    + qPriorModLev(L)

    	                aijl(i,j,L,IJL_DP_TES_R)=
     *                    aijl(i,j,L,IJL_DP_TES_R) + 1.

#ifdef CACHED_SUBDD
                        HDORSUBD(i,j,l)=hdoModelNewSH(L)
                        H2ORSUBD(i,j,l)=h2oModelNewSH(L)
                        nTESRGoodSUBD(i,j,l)= 
     *                      nTESRGoodSUBD(i,j,l)+ 1.
#endif
                       endif

                       if (maxSen(L).ne.undef 
     &                    .and. maxSenHt(L).ne.undef) then
                           aijl(i,j,L,IJL_TES_SEN_R) = 
     *                       aijl(i,j,L,IJL_TES_SEN_R) + maxSen(L)
                           aijl(i,j,L,IJL_TES_SEN_HT_R) = 
     *                       aijl(i,j,L,IJL_TES_SEN_HT_R) + maxSenHt(L)
                       endif 
 
                       enddo

C                     currSecITU
                      endif
C                 currOb
                  enddo 
C             currNObs 
              endif   
C             ABS(LAT_DG
              endif
C         i
          enddo 
C     j
      enddo
C     ALLOCATED
      END IF
      
      END SUBROUTINE ApplyTESOpRetrievalAK
      

      SUBROUTINE InitializeISCCPRandIndices(I_0,I_1,J_0,J_1)
C********************************************************************** 
C Description: Randomly select a number between 1 and ncol, assign to 
C array, for use in operator routines in selecting an ISCCP subgrid 
C column randomnly.
C********************************************************************** 
      USE TES_SIMULATOR
      USE CLOUDS_COM, only: ncol
      USE RANDOM
      integer :: nij_before_j0,nij_after_j1,nij_after_i1

      INTEGER,INTENT(IN) :: I_0,I_1,J_0,J_1

      INTEGER :: nI,nJ,I,J,code,randISCCPCol,oldSeed
      REAL*8 xx


      IF (ALLOCATED(ISCCPRandIndex)) THEN
           DEALLOCATE(ISCCPRandIndex)
      END IF

      ALLOCATE(ISCCPRandIndex(I_0:I_1,J_0:J_1),STAT=code)

C**** 
C**** Set up 2D array of random numbers over local domain.
C**** This is required for probability-based profile quality filtering.
C**** RINIT and RFINAL are called so that these calls don't affect 
C**** prognostic quantities that use RANDU.
C**** 

C     Save current random number seed
      CALL RFINAL(oldSeed)

C     Create random number array
      CALL BURN_RANDOM(nij_before_j0(J_0))
      DO J=J_0,J_1
          CALL BURN_RANDOM((I_0-1))
          DO I=I_0,I_1
              ISCCPRandIndex(I,J) = CEILING(ncol*RANDU(xx))
          END DO
          CALL BURN_RANDOM(nij_after_i1(I_1))
      END DO
      CALL BURN_RANDOM(nij_after_j1(J_1))

C     Restore old random number seeed
      CALL RINIT(oldSeed)

      END SUBROUTINE InitializeISCCPRandIndices


      SUBROUTINE InitializeTESSUBDD(I_0,I_1,J_0,J_1)
C********************************************************************** 
C Description: Initialize array for subdaily dD diagnostics.
C********************************************************************** 
      USE TES_SIMULATOR
      USE CONSTANT, only : undef
      USE MODEL_COM, only : lm

      INTEGER,INTENT(IN) :: I_0,I_1,J_0,J_1

      INTEGER ::I,J,L,code

      
      IF (.NOT.ALLOCATED(nTESSUBD)) THEN
           ALLOCATE(nTESSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(nTESCGoodSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(nTESRGoodSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(HDORawSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(H2ORawSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(HDOCSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(H2OCSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(HDORSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
           ALLOCATE(H2ORSUBD(I_0:I_1,J_0:J_1,LM),STAT=code)
      END IF

      DO j=J_0,J_1
          DO i=I_0,I_1
              DO l=1,LM
                  nTESSUBD(i,j,l) = 0.
                  nTESCGoodSUBD(i,j,l) = 0.
                  nTESRGoodSUBD(i,j,l) = 0.
                  HDORawSUBD(i,j,l)= 0.
                  H2ORawSUBD(i,j,l) = 0.
                  HDOCSUBD(i,j,l) = 0.
                  H2OCSUBD(i,j,l) = 0.
                  HDORSUBD(i,j,l) = 0.
                  H2ORSUBD(i,j,l) = 0.
              ENDDO
          ENDDO
      ENDDO

      END SUBROUTINE InitializeTESSUBDD



C********************************************************************** 
C Description: Map daily point-wise data to the ModelE grid. This is very 
C ModelE specfic, and has been separated from ReadDailyTESFile.
C********************************************************************** 
      SUBROUTINE InitializeTESOperatorCollocation(I_0,I_1,J_0,J_1,
     &           localNObs)

      USE TES_SIMULATOR
      USE CONSTANT, only : undef
      USE DOMAIN_DECOMP_1D, only : grid, unpack_data, am_i_root 
      USE GEOM, ONLY: lat2d_dg,lon2d_dg
      USE MODEL_COM, ONLY : ITIME

      IMPLICIT NONE

C 
C                               INPUT
C
      INTEGER, INTENT(IN) :: I_0,I_1,J_0,J_1
      INTEGER, INTENT(IN) :: localNObs
C 
C                               OUTPUT
C

C 
C                               LOCAL VARIABLES
C
      INTEGER :: currOb,currSecond,currGoodObs
      INTEGER :: currModLatInd,currModLonInd
      INTEGER :: I,J,code

    
C**** Allocate the relevant grid arrays
      IF (ALLOCATED(nObsGrid)) THEN
        DEALLOCATE(avgKrnlsH2OGrid,
     & avgKrnlsHDOGrid,
     & avgKrnlsHDGrid,
     & avgKrnlsDHGrid,
     & qPriorsGrid,
     & dDPriorsGrid,
     & nObsGrid,
     & goodObFlag,
     & secOfDayGrid)
      END IF

      ALLOCATE(nObsGrid(I_0:I_1,J_0:J_1),STAT=code)
      ALLOCATE(goodObFlag(I_0:I_1,J_0:J_1,maxObsPerCell),STAT=code)
      ALLOCATE(secOfDayGrid(I_0:I_1,J_0:J_1,maxObsPerCell),STAT=code)
      ALLOCATE(avgKrnlsH2OGrid(I_0:I_1,J_0:J_1,maxObsPerCell,
     & nDataLevsPt,nAvgKrnlLevsPt),
     & STAT=code)
      ALLOCATE(avgKrnlsHDOGrid(I_0:I_1,J_0:J_1,maxObsPerCell,
     & nDataLevsPt,nAvgKrnlLevsPt),
     & STAT=code)
      ALLOCATE(avgKrnlsHDGrid(I_0:I_1,J_0:J_1,maxObsPerCell,
     & nDataLevsPt,nAvgKrnlLevsPt),
     & STAT=code)
      ALLOCATE(avgKrnlsDHGrid(I_0:I_1,J_0:J_1,maxObsPerCell,
     & nDataLevsPt,nAvgKrnlLevsPt),
     & STAT=code)
      ALLOCATE(qPriorsGrid(I_0:I_1,J_0:J_1,maxObsPerCell,nTESLevsPt),
     & STAT=code)
      ALLOCATE(dDPriorsGrid(I_0:I_1,J_0:J_1,maxObsPerCell,nTESLevsPt),
     & STAT=code)

C**** Set counter array to 0
      DO I=I_0,I_1
          DO J=J_0,J_1
              nObsGrid(I,J) = 0
              DO currOb = 1,maxObsPerCell
                  secOfDayGrid(I,J,currOb) = undef
                  goodObFlag(I,J,currOb) = 0
              ENDDO
          ENDDO
      ENDDO

C**** Map each observation onto local grid, taking into account cases
C**** when there are more than 1 observation per grid cell
      DO currOb=1,localNObs
          currSecond  = secondsPt(currOb)
          currModLatInd = latIndPt(currOb)
          currModLonInd = lonIndPt(currOb)

C****     Only concerned with observations on local domain          
          IF ((currModLonInd >= I_0) .and. (currModLonInd <= I_1) .and.
     &        (currModLatInd >= J_0) .and.(currModLatInd <= J_1))THEN

C****         Increment the number of observations in the cell.
C****         The cell value of nObsGrid also becomes an index
C****         for the point info mapped onto the grid.    
              nObsGrid(currModLonInd,currModLatInd) = 
     &        nObsGrid(currModLonInd,currModLatInd) + 1

C****         Store the observation time, in seconds from midnight
              secOfDayGrid(currModLonInd,currModLatInd,
     &            nObsGrid(currModLonInd,currModLatInd)) 
     &            = currSecond

C****         Store the four averaging kernels and priors
              avgKrnlsH2OGrid(currModLonInd,currModLatInd,
     &            nObsGrid(currModLonInd,currModLatInd),:,:) 
     &            = avgKrnlsH2OPt(:,:,currOb)

              avgKrnlsHDOGrid(currModLonInd,currModLatInd,
     &            nObsGrid(currModLonInd,currModLatInd),:,:) 
     &            = avgKrnlsHDOPt(:,:,currOb)

              avgKrnlsHDGrid(currModLonInd,currModLatInd,
     &            nObsGrid(currModLonInd,currModLatInd),:,:) 
     &            = avgKrnlsHDPt(:,:,currOb)

              avgKrnlsDHGrid(currModLonInd,currModLatInd,
     &            nObsGrid(currModLonInd,currModLatInd),:,:) 
     &            = avgKrnlsDHPt(:,:,currOb)

              qPriorsGrid(currModLonInd,currModLatInd,
     &            nObsGrid(currModLonInd,currModLatInd),:) 
     &            = qPriorPt(:,currOb)

              dDPriorsGrid(currModLonInd,currModLatInd,
     &            nObsGrid(currModLonInd,currModLatInd),:) 
     &            = dDPriorPt(:,currOb)

C****         Note which observations have good quality and 
C****         high sensitivity.
              IF (H2ODegFrPt(currOb) >= TESObsMinDegFr .and. 
     &           HDODegFrPt(currOb) >= TESObsMinDegFr .and.
     &           (H2OQualPt(currOb) .eq. 1) .and.
     &           (HDOQualPt(currOb) .eq. 1)) THEN

                  goodObFlag(currModLonInd,currModLatInd,
     &                nObsGrid(currModLonInd,currModLatInd)) = 1
              ELSE
C****             Flag this as a bad observation
                  goodObFlag(currModLonInd,currModLatInd,
     &                nObsGrid(currModLonInd,currModLatInd)) = 0
              END IF
          END IF
      ENDDO

      END SUBROUTINE InitializeTESOperatorCollocation

C********************************************************************** 
C********************************************************************** 
C
C               Routines that should be model-independent
C
C********************************************************************** 
C**********************************************************************

      SUBROUTINE ReadDailyTESFile(currYear,currMonth,currDay,localNObs)
C********************************************************************** 
C Description: Read in point-wise data from daily TES netcdf file.
C********************************************************************** 
      USE TES_SIMULATOR

      IMPLICIT NONE
      include 'netcdf.inc'
C 
C                               INPUT:
C
      INTEGER, INTENT(IN) :: currYear,currMonth,currDay
C 
C                               OUTPUT:
C 
      INTEGER, INTENT(OUT) :: localNObs
C 
C                             LOCAL VARIABLES
C
      INTEGER :: netcdfID,status,code
      character(len=4) :: yearStr
      character(len=4) :: monthStr
      character(len=4) :: dayStr
      character(len=16) :: dateStr
      character(len=256) :: TESFilePath

!@var netcdf variable for dimension IDs
      INTEGER :: nLocationsID,nTESLevsID,nDataLevsID,nAvgKrnlLevsID
      INTEGER :: timeStrLenID

!@var netcdf variable for variables IDs
      INTEGER :: TESPresLevID,TESDataLevID,TESAvgKrnlLevID      
      INTEGER :: avgKrnlH2OID,avgKrnlHDOID,avgKrnlHDID,avgKrnlDHID
      INTEGER :: qPriorID,dDPriorID
      INTEGER :: timeStrID,secondsID,dayTimeFlagID
      INTEGER :: latVectorID,lonVectorID
      INTEGER :: modelLatID,modelLonID,modLatIndID,modLonIndID
      INTEGER :: H2ODegFrID,HDODegFrID,H2OQualID,HDOQualID


C**** Deallocate the point or grid arrays if they already exist
      IF (ALLOCATED(TESPresPt)) THEN
       DEALLOCATE(TESPresPt,TESDataLevsPt,TESAvgKrnlLevsPt, 
     & avgKrnlsH2OPt,avgKrnlsHDOPt, 
     & avgKrnlsHDPt,avgKrnlsDHPt,qPriorPt,dDPriorPt,
     & secondsPt,dayTimeFlagPt,latVecPt,lonVecPt,
     & latIndPt,lonIndPt,H2ODegFrPt,HDODegFrPt,
     & H2OQualPt,HDOQualPt)
      END IF

C**********************************************************************
C**** Read in daily point data from netcdf file
C****

C**** Try opening daily netcdf file, which has YYYY.MM.DD.nc format
      write(yearStr,'(I0)') currYear
      write(monthStr,'(I0)') currMonth
      write(dayStr,'(I0)') currDay

C     should be better way for this
      if (currMonth .lt. 10) then
          monthStr = '0'//monthStr
      end if
      if (currDay .lt. 10) then
          dayStr = '0'//dayStr
      end if
    
      dateStr = yearStr//'.'//trim(monthStr)//'.'//trim(dayStr)//'.nc'
      TESFilePath = trim(TESObsDataDir)//trim(dateStr)

      status=NF_OPEN(TESFilePath,NCNOWRIT,netcdfID)

      IF ( status .ne. NF_NOERR ) THEN
          print *,'No TES file found: ',TESFilePath
      ELSE
C**** Daily TES file exists, proceed
      print *,'TES file found: ',TESFilePath
C**** Retrieve dimension IDs
      status=NF_INQ_DIMID(netcdfID,'nLocations',nLocationsID)
      status=NF_INQ_DIMID(netcdfID,'tesLevelDim',nTESLevsID)
      status=NF_INQ_DIMID(netcdfID,'dataLevelDim',nDataLevsID)
      status=NF_INQ_DIMID(netcdfID,'avgKrnlLevelDim',
     &                        nAvgKrnlLevsID)
      status=NF_INQ_DIMID(netcdfID,'timeStrLenDim',timeStrLenID)

C**** Retrieve variable IDs
      status=NF_INQ_VARID(netcdfID,'tesPressureLevels',
     & TESPresLevID)
      status=NF_INQ_VARID(netcdfID,'dataLevels',TESDataLevID)
      status=NF_INQ_VARID(netcdfID,'avgKernelLevels',
     & TESAvgKrnlLevID)
      status=NF_INQ_VARID(netcdfID,'H2OAvgKernels',avgKrnlH2OID)
      status=NF_INQ_VARID(netcdfID,'HDOAvgKernels',avgKrnlHDOID)
      status=NF_INQ_VARID(netcdfID,'HDCrossKernels',avgKrnlHDID)
      status=NF_INQ_VARID(netcdfID,'DHCrossKernels',avgKrnlDHID)
      status=NF_INQ_VARID(netcdfID,'qPrior',qPriorID)
      status=NF_INQ_VARID(netcdfID,'dDPrior',dDPriorID)
      status=NF_INQ_VARID(netcdfID,'seconds',secondsID)
      status=NF_INQ_VARID(netcdfID,'dayTimeFlag',dayTimeFlagID)
      status=NF_INQ_VARID(netcdfID,'latVector',latVectorID)
      status=NF_INQ_VARID(netcdfID,'lonVector',lonVectorID)
      status=NF_INQ_VARID(netcdfID,'latIndices',modLatIndID)
      status=NF_INQ_VARID(netcdfID,'lonIndices',modLonIndID)
      status=NF_INQ_VARID(netcdfID,'H2ODegFr',H2ODegFrID)
      status=NF_INQ_VARID(netcdfID,'HDODegFr',HDODegFrID)
      status=NF_INQ_VARID(netcdfID,'HDOSpeciesQuality',H2OQualID)
      status=NF_INQ_VARID(netcdfID,'H2OSpeciesQuality',HDOQualID)

C**** Retrieve dimensions
      status=NF_INQ_DIMLEN(netcdfID,nLocationsID,localNObs)
      status=NF_INQ_DIMLEN(netcdfID,timeStrLenID,timeStrLen)
      status=NF_INQ_DIMLEN(netcdfID,nTESLevsID,nTESLevsPt)
      status=NF_INQ_DIMLEN(netcdfID,nDataLevsID,nDataLevsPt)
      status=NF_INQ_DIMLEN(netcdfID,nAvgKrnlLevsID,nAvgKrnlLevsPt)

C**** Allocate apace
      ALLOCATE(TESPresPt(nTESLevsPt,localNObs),STAT=code)
      ALLOCATE(TESDataLevsPt(nDataLevs),STAT=code)
      ALLOCATE(TESAvgKrnlLevsPt(nAvgKrnlLevs),STAT=code)
      ALLOCATE(avgKrnlsH2OPt(nDataLevsPt,nAvgKrnlLevsPt,localNObs),
     & STAT=code)
      ALLOCATE(avgKrnlsHDOPt(nDataLevsPt,nAvgKrnlLevsPt,localNObs),
     & STAT=code)
      ALLOCATE(avgKrnlsHDPt(nDataLevsPt,nAvgKrnlLevsPt,localNObs),
     & STAT=code)
      ALLOCATE(avgKrnlsDHPt(nDataLevsPt,nAvgKrnlLevsPt,localNObs),
     & STAT=code)
      ALLOCATE(qPriorPt(nTESLevsPt,localNObs),
     & STAT=code)
      ALLOCATE(dDPriorPt(nTESLevsPt,localNObs),
     & STAT=code)
      ALLOCATE(secondsPt(localNObs),STAT=code)
      ALLOCATE(dayTimeFlagPt(localNObs),STAT=code)
      ALLOCATE(latVecPt(localNObs),STAT=code)
      ALLOCATE(lonVecPt(localNObs),STAT=code)
      ALLOCATE(latIndPt(localNObs),STAT=code)
      ALLOCATE(lonIndPt(localNObs),STAT=code)
      ALLOCATE(H2ODegFrPt(localNObs),STAT=code)
      ALLOCATE(HDODegFrPt(localNObs),STAT=code)
      ALLOCATE(H2OQualPt(localNObs),STAT=code)
      ALLOCATE(HDOQualPt(localNObs),STAT=code)

C**** Retrieve data
      status = NF_GET_VAR_DOUBLE(netcdfID,TESPresLevID,TESPresPt)
      status = NF_GET_VAR_INT(netcdfID,TESDataLevID,TESDataLevsPt)
      status = NF_GET_VAR_INT(netcdfID,TESAvgKrnlLevID,
     & TESAvgKrnlLevsPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,avgKrnlH2OID,avgKrnlsH2OPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,avgKrnlHDOID,avgKrnlsHDOPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,avgKrnlHDID,avgKrnlsHDPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,avgKrnlDHID,avgKrnlsDHPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,qPriorID,qPriorPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,dDPriorID,dDPriorPt)
      status = NF_GET_VAR_INT(netcdfID,secondsID,secondsPt)
      status = NF_GET_VAR_INT(netcdfID,dayTimeFlagID,dayTimeFlagPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,latVectorID,latVecPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,lonVectorID,lonVecPt)
      status = NF_GET_VAR_INT(netcdfID,modLatIndID,latIndPt)
      status = NF_GET_VAR_INT(netcdfID,modLonIndID,lonIndPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,H2ODegFrID,H2ODegFrPt)
      status = NF_GET_VAR_DOUBLE(netcdfID,HDODegFrID,HDODegFrPt)
      status = NF_GET_VAR_INT(netcdfID,H2OQualID,H2OQualPt)
      status = NF_GET_VAR_INT(netcdfID,HDOQualID,HDOQualPt)

      status=NF_CLOSE(netcdfID)
      END IF
      END SUBROUTINE ReadDailyTESFile


      SUBROUTINE ReadTESAvgKrnlFile()
C********************************************************************** 
C Description: Reads in categorical averaging kernel information from 
C              the file TESAvgKrnlFileName
C********************************************************************** 
      USE TES_SIMULATOR
      USE DOMAIN_DECOMP_1D, only : am_i_root 	  
      IMPLICIT NONE
      include 'netcdf.inc'
C 
C                               INPUT:
C
!@var theDirectory the directory where the files reside
C     CHARACTER, INTENT(IN) :: fileName 
C 
C                                 OUTPUT:
C
 
C 
C                             LOCAL VARIABLES
C
!@var netcdf variable for file ID
      INTEGER :: netcdfID,status
!@var netcdf variable for dimension IDs
      INTEGER :: nTESLevsID,nDataLevsID,nAvgKrnlLevsID
      INTEGER :: timeStrLenID
      INTEGER :: nSrfTypeCatsID
      INTEGER :: nsrfTmpCatsID,noptDepCatsID,ncldTopPresCatsID
      INTEGER :: npwLowCatsID,npwHighCatsID
      INTEGER :: code,i,j

!@var netcdf variable for variables IDs
      INTEGER :: TESPresLevID,TESDataLevID,TESAvgKrnlLevID
      INTEGER :: srfTypeCatsID      
      INTEGER :: srfTmpCatsID,optDepCatsID,cldTopPresCatsID
      INTEGER :: pwLowCatsID,pwHighCatsID
      INTEGER :: avgKrnlH2OID,avgKrnlHDOID,avgKrnlHDID,avgKrnlDHID
      INTEGER :: percGoodObsID
      INTEGER :: latBdyID,bdyLyrDepID
      INTEGER :: qPriorID,rPriorID

      INTEGER :: startAK(8),countAK(8)
      INTEGER :: startQPrior(7),countQPrior(7)
      INTEGER :: startPercGood(6),countPercGood(6)
       

!@var qPriorSingle if overwriting with a single q prior profile
      REAL*8, ALLOCATABLE,DIMENSION(:) :: qPriorSingle
      REAL*8, ALLOCATABLE,DIMENSION(:,:) :: H2OAKSingle, DHAKSingle,
     &                                    HDAKSingle

      INTEGER :: currSrfType
      INTEGER :: currTmp,currCOD,currCTP
      INTEGER :: currPWLow,currPWHigh,currTESLev

C**** Open netcdf file
      status=NF_OPEN('TES_AK',NCNOWRIT,netcdfID)
      if ( status .ne. NF_NOERR ) then
	     call stop_model('Error opening: TES_AK',255)
      endif
    
C
C   SHOULD ADD MORE ERROR CHECKING
C
C**** Retrieve dimension IDs 
      status=NF_INQ_DIMID(netcdfID,'tesLevelDim',nTESLevsID)
      status=NF_INQ_DIMID(netcdfID,'dataLevelDim',nDataLevsID)
      status=NF_INQ_DIMID(netcdfID,'avgKrnlLevelDim',nAvgKrnlLevsID)

      status=NF_INQ_DIMID(netcdfID,'srfTypeCatsDim',nSrfTypeCatsID)
      status=NF_INQ_DIMID(netcdfID,'srfTmpCatsDim',nsrfTmpCatsID)
      status=NF_INQ_DIMID(netcdfID,'optDepCatsDim',noptDepCatsID)
      status=NF_INQ_DIMID(netcdfID,
     &                    'cldTopPresCatsDim',ncldTopPresCatsID)
      status=NF_INQ_DIMID(netcdfID,'pwLowCatsDim',npwLowCatsID)
      status=NF_INQ_DIMID(netcdfID,'pwHighCatsDim',npwHighCatsID)

C**** Retrieve variable IDs 
      status=NF_INQ_VARID(netcdfID,'tesPressureLevels',TESPresLevID)
      status=NF_INQ_VARID(netcdfID,'dataLevels',TESDataLevID)
      status=NF_INQ_VARID(netcdfID,'avgKernelLevels',TESAvgKrnlLevID)
      status=NF_INQ_VARID(netcdfID,'H2OAvgKernels',avgKrnlH2OID)
      status=NF_INQ_VARID(netcdfID,'HDOAvgKernels',avgKrnlHDOID)
      status=NF_INQ_VARID(netcdfID,'HDCrossKernels',avgKrnlHDID)
      status=NF_INQ_VARID(netcdfID,'DHCrossKernels',avgKrnlDHID)
      status=NF_INQ_VARID(netcdfID,'percGoodObs',percGoodObsID)
      status=NF_INQ_VARID(netcdfID,'srfTypeCats',srfTypeCatsID)
      status=NF_INQ_VARID(netcdfID,'srfTmpCats',srfTmpCatsID)
      status=NF_INQ_VARID(netcdfID,'optDepCats',optDepCatsID)
      status=NF_INQ_VARID(netcdfID,'cldTopPresCats',cldTopPresCatsID)
      status=NF_INQ_VARID(netcdfID,'pwLowCats',pwLowCatsID)
      status=NF_INQ_VARID(netcdfID,'pwHighCats',pwHighCatsID)

      status=NF_INQ_VARID(netcdfID,'qPriors',qPriorID)
      status=NF_INQ_VARID(netcdfID,'RPrior',rPriorID)

      status=NF_INQ_VARID(netcdfID,'latBoundary',latBdyID)
      status=NF_INQ_VARID(netcdfID,'bdyLayerDepth',bdyLyrDepID)

C**** Retrieve dimensions
      status=NF_INQ_DIMLEN(netcdfID,nTESLevsID,nTESLevs)
      status=NF_INQ_DIMLEN(netcdfID,nDataLevsID,nDataLevs)
      status=NF_INQ_DIMLEN(netcdfID,nAvgKrnlLevsID,nAvgKrnlLevs)

      status=NF_INQ_DIMLEN(netcdfID,nSrfTypeCatsID,nSrfTypeCats)
      status=NF_INQ_DIMLEN(netcdfID,nsrfTmpCatsID,nsrfTmpCats)
      status=NF_INQ_DIMLEN(netcdfID,noptDepCatsID,noptDepCats)
      status=NF_INQ_DIMLEN(netcdfID,ncldTopPresCatsID,ncldTopPresCats)
      status=NF_INQ_DIMLEN(netcdfID,npwLowCatsID,npwLowCats)
      status=NF_INQ_DIMLEN(netcdfID,npwHighCatsID,npwHighCats)

C**** Allocate space
      ALLOCATE(TESPres(nTESLevs),STAT=code)
      ALLOCATE(TESDataLevs(nDataLevs),STAT=code)
      ALLOCATE(TESAvgKrnlLevs(nAvgKrnlLevs),STAT=code)

      ALLOCATE(srfTypeCats(nSrfTypeCats),STAT=code)
      ALLOCATE(srfTmpCats(nsrfTmpCats),STAT=code)
      ALLOCATE(optDepCats(noptDepCats),STAT=code)
      ALLOCATE(cldTopPresCats(ncldTopPresCats),STAT=code)
      ALLOCATE(pwLowCats(npwLowCats),STAT=code)
      ALLOCATE(pwHighCats(npwHighCats),STAT=code)

      ALLOCATE(avgKrnlsH2OO(nsrfTmpCats-1
     &                    ,noptDepCats-1,ncldTopPresCats-1
     &                    ,npwLowCats-1,npwHighCats-1
     &                    ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(avgKrnlsHDOO(nsrfTmpCats-1
     &                    ,noptDepCats-1,ncldTopPresCats-1
     &                    ,npwLowCats-1,npwHighCats-1
     &                    ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(avgKrnlsHDO(nsrfTmpCats-1
     &                   ,noptDepCats-1,ncldTopPresCats-1
     &                   ,npwLowCats-1,npwHighCats-1
     &                   ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(avgKrnlsDHO(nsrfTmpCats-1
     &                   ,noptDepCats-1,ncldTopPresCats-1
     &                   ,npwLowCats-1,npwHighCats-1
     &                   ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(qPriorsO(nsrfTmpCats-1
     &                ,noptDepCats-1,ncldTopPresCats-1
     &                ,npwLowCats-1,npwHighCats-1
     &                ,nTESLevs),STAT=code)
      ALLOCATE(percGoodObsO(nsrfTmpCats-1
     &                ,noptDepCats-1,ncldTopPresCats-1
     &                ,npwLowCats-1,npwHighCats-1),STAT=code)
      ALLOCATE(rPrior(nTESLevs),STAT=code)

      ALLOCATE(avgKrnlsH2OL(nsrfTmpCats-1
     &                    ,noptDepCats-1,ncldTopPresCats-1
     &                    ,npwLowCats-1,npwHighCats-1
     &                    ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(avgKrnlsHDOL(nsrfTmpCats-1
     &                    ,noptDepCats-1,ncldTopPresCats-1
     &                    ,npwLowCats-1,npwHighCats-1
     &                    ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(avgKrnlsHDL(nsrfTmpCats-1
     &                   ,noptDepCats-1,ncldTopPresCats-1
     &                   ,npwLowCats-1,npwHighCats-1
     &                   ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(avgKrnlsDHL(nsrfTmpCats-1
     &                   ,noptDepCats-1,ncldTopPresCats-1
     &                   ,npwLowCats-1,npwHighCats-1
     &                   ,nDataLevs,nAvgKrnlLevs),STAT=code)
      ALLOCATE(qPriorsL(nsrfTmpCats-1
     &                ,noptDepCats-1,ncldTopPresCats-1
     &                ,npwLowCats-1,npwHighCats-1
     &                ,nTESLevs),STAT=code)
      ALLOCATE(percGoodObsL(nsrfTmpCats-1
     &                ,noptDepCats-1,ncldTopPresCats-1
     &                ,npwLowCats-1,npwHighCats-1),STAT=code)


C**** Where de-allocate?

C**** Retrieve data into variables
      status = NF_GET_VAR_DOUBLE(netcdfID,TESPresLevID,TESPres)
      status = NF_GET_VAR_INT(netcdfID,TESDataLevID,TESDataLevs)
      status = NF_GET_VAR_INT(netcdfID,TESAvgKrnlLevID,TESAvgKrnlLevs)
      status = NF_GET_VAR_INT(netcdfID,srfTypeCatsID,srfTypeCats)
      status = NF_GET_VAR_DOUBLE(netcdfID,srfTmpCatsID,srfTmpCats)
      status = NF_GET_VAR_DOUBLE(netcdfID,optDepCatsID,optDepCats)
      status = NF_GET_VAR_DOUBLE(netcdfID,cldTopPresCatsID,
     &                           cldTopPresCats)
      status = NF_GET_VAR_DOUBLE(netcdfID,pwLowCatsID,pwLowCats)
      status = NF_GET_VAR_DOUBLE(netcdfID,pwHighCatsID,pwHighCats)

C**** Read in ocean portion of netcdf AK file
      startAK = (/1,1,1,1,1,1,1,1/)
      countAK = (/1,nsrfTmpCats-1
     &            ,noptDepCats-1,ncldTopPresCats-1
     &            ,npwLowCats-1,npwHighCats-1
     &            ,nDataLevs,nAvgKrnlLevs/)	
      startQPrior = (/1,1,1,1,1,1,1/)
      countQPrior = (/1,nsrfTmpCats-1
     &            ,noptDepCats-1,ncldTopPresCats-1
     &            ,npwLowCats-1,npwHighCats-1
     &            ,nTESLevs/)	
      startPercGood = (/1,1,1,1,1,1/)
      countPercGood = (/1,nsrfTmpCats-1
     &            ,noptDepCats-1,ncldTopPresCats-1
     &            ,npwLowCats-1,npwHighCats-1/)

      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlH2OID,
     &         startAK,countAK,avgKrnlsH2OO)
      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlHDOID,
     &         startAK,countAK,avgKrnlsHDOO)
      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlHDID,
     &         startAK,countAK,avgKrnlsHDO)
      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlDHID,
     &         startAK,countAK,avgKrnlsDHO)
      status = NF_GET_VARA_DOUBLE(netcdfID,percGoodObsID,
     &         startPercGood,countPercGood,percGoodObsO)
      status = NF_GET_VARA_DOUBLE(netcdfID,qPriorID,
     &         startQPrior,countQPrior,qPriorsO)

C**** Read in land portion of netcdf file, if it exists
      IF (nSrfTypeCats.gt.2) THEN
      startAK = (/2,1,1,1,1,1,1,1/)
      startQPrior = (/2,1,1,1,1,1,1/)
      startPercGood = (/2,1,1,1,1,1/)
      END IF

      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlH2OID,
     &         startAK,countAK,avgKrnlsH2OL)
      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlHDOID,
     &         startAK,countAK,avgKrnlsHDOL)
      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlHDID,
     &         startAK,countAK,avgKrnlsHDL)
      status = NF_GET_VARA_DOUBLE(netcdfID,avgKrnlDHID,
     &         startAK,countAK,avgKrnlsDHL)
      status = NF_GET_VARA_DOUBLE(netcdfID,percGoodObsID,
     &         startPercGood,countPercGood,percGoodObsL)
      status = NF_GET_VARA_DOUBLE(netcdfID,qPriorID,
     &         startQPrior,countQPrior,qPriorsL)
  
  
      status = NF_GET_VAR_DOUBLE(netcdfID,rPriorID,rPrior)

      status = NF_GET_VAR_DOUBLE(netcdfID,latBdyID,latBdy)
      status = NF_GET_VAR_DOUBLE(netcdfID,bdyLyrDepID,bdyLyrDep)

      status=NF_CLOSE(netcdfID)

C**** Option to use qPrior from 'Single' 
C**** universally

      IF (TESCatVariableHDOAKOnly.eq.1) THEN
          status=NF_OPEN('TES_SINGLE',NCNOWRIT,netcdfID)
          if ( status .ne. NF_NOERR ) then
	     call stop_model('Error opening: TES_SINGLE',255)
          endif
          status= NF_INQ_VARID(netcdfID,'qPriors',qPriorID)

          ALLOCATE(qPriorSingle(nTESLevs),STAT=code)

          status = NF_GET_VAR_DOUBLE(netcdfID,qPriorID,qPriorSingle)

          DO currTmp=1,(nsrfTmpCats-1)
          DO currCOD=1,(noptDepCats-1)
          DO currCTP=1,(ncldTopPresCats-1)
          DO currPWLow=1,(npwLowCats-1)
          DO currPWHigh=1,(npwHighCats-1)
 
          DO currTESLev = 1,nTESLevs
              qPriorsO(currTmp,currCOD,currCTP,
     &                currPWLow,currPWHigh,currTESLev)
     &                = qPriorSingle(currTESLev)
              qPriorsL(currTmp,currCOD,currCTP,
     &                currPWLow,currPWHigh,currTESLev)
     &                = qPriorSingle(currTESLev)
          ENDDO

          ENDDO
          ENDDO
          ENDDO
          ENDDO
          ENDDO
          status=NF_CLOSE(netcdfID)
      END IF

      END SUBROUTINE ReadTESAvgKrnlFile

      SUBROUTINE RetrieveAKIndices(cldOD,cldTP,tSurf,pwLow,pwHigh
     * ,nCldODCats,nCldTPCats,nTSurfCats,nPwLowCats,nPwHighCats
     * ,cldODCats,cldTPCats,tSurfCats,pwLowCats,pwHighCats	 
     * ,cldODIndex,cldTPIndex,tSurfIndex,pwLowIndex,pwHighIndex)
C********************************************************************** 
C Description: Given model cldOD, cldTP,tSurf,pwLow,pwHigh and the 
C              corresponding categorical 'bins', return the indices
C              for the corresponding averaging kernel and prior. 
C              Any returned values of '0' indicate a problem.
C********************************************************************** 
C 
      USE CONSTANT, only : undef
      IMPLICIT NONE
C 
C                               INPUT:
C
!@var cldOD cloud optical depth
!@var tsurf surface (ground) temperature (deg C)
!@var cldTP cloud top pressure (hPa)
!@var pwLow precipitable water in 'boundary layer'
!@var pwHigh precipitable water in free atmosphere
      REAL*8, INTENT(IN) :: cldOD, cldTP,tSurf,pwLow,pwHigh
!@var nCldODCats number of cloud optical depth categories
!@var nCldTPCats number of cloud top pressure categories
!@var nTSurfCats number of surface temperature categories
!@var nPwLowCats number of bdy layer precipitable water categories
!@var nPwHighCats number of free atmosphere pw categories
      INTEGER, INTENT(IN) :: nCldODCats,nCldTPCats,nTSurfCats
      INTEGER, INTENT(IN) :: nPwLowCats,nPwHighCats
!@var cldODCats cloud optical depth categories
!@var cldTPCats cloud top pressure categories
!@var tSurfCats surface temperature categories
!@var pwLowCats bdy layer precipitable water categories
!@var pwHighCats free atmosphere precip water categories
      REAL*8, INTENT(IN), DIMENSION(nCldODCats) :: cldODCats 
      REAL*8, INTENT(IN), DIMENSION(nCldTPCats) :: cldTPCats 
      REAL*8, INTENT(IN), DIMENSION(nTSurfCats) :: tSurfCats 
      REAL*8, INTENT(IN), DIMENSION(nTSurfCats) :: pwLowCats 
      REAL*8, INTENT(IN), DIMENSION(nTSurfCats) :: pwHighCats 
C 
C                               OUTPUT:
C
!@var cldODIndex index of cldODCats corresponding to cldOD
!@var cldTPIndex index of cldTPCats corresponding to cldTP
!@var tSurfIndex index of tSurfCats corresponding to tSurf
!@var pwLowIndex index of pwLowCats corresponding to pwLow
!@var pwHighIndex index of pwHighCats corresponding to pwHigh
      INTEGER, INTENT(OUT) :: cldODIndex,cldTPIndex,tSurfIndex
      INTEGER, INTENT(OUT) :: pwLowIndex,pwHighIndex

C 
C                               INTERNAL:
C
      INTEGER currCat

      tSurfIndex = 0
      DO currCat=1,nTSurfCats-1
          if (tSurf.ge.tsurfCats(currCat) 
     &  .and. tsurf.lt.tsurfCats(currCat+1)) then
              tSurfIndex = currCat
          endif
      ENDDO
       
      cldODIndex = 0
      DO currCat=1,nCldODCats-1
          if (cldOD.ge.cldODCats(currCat) 
     &  .and. cldOD.lt.cldODCats(currCat+1)) then
              cldODIndex = currCat
          endif
      ENDDO
     
      cldTPIndex = 0
      DO currCat=1,nCldTPCats-1
          if (cldTP.ge.cldTPCats(currCat) 
     &  .and. cldTP.lt.cldTPCats(currCat+1)) then
              cldTPIndex = currCat
          endif
      ENDDO

      pwLowIndex = 0
      DO currCat=1,nPwLowCats-1
          if (pwLow.ge.pwLowCats(currCat) 
     &  .and. pwLow.lt.pwLowCats(currCat+1)) then
              pwLowIndex = currCat
          endif
      ENDDO

      pwHIghIndex = 0
      DO currCat=1,nPwHighCats-1
          if (pwHigh.ge.pwHighCats(currCat) 
     &  .and. pwHigh.lt.pwHighCats(currCat+1)) then
              pwHighIndex = currCat
          endif
      ENDDO

      END SUBROUTINE RetrieveAKIndices


      SUBROUTINE ApplyTESOperator(nPresTES,presTES
     *     ,h2oModelSH,hdoModelSH,presModel
     *     ,qPrior,rPrior
     *     ,nDataLev,nAKLev,dataLevIndTES,tesAKIndTES
     *     ,H2OAK,HDOAK,HDAK,DHAK
     *     ,h2oModelNewSH,hdoModelNewSH
     *     ,h2oModelIntpSH,hdoModelIntpSH
     *     ,qPriorModLev,maxSen,maxSenHt)
C********************************************************************** 
C Description: Given model and prior profiles of q and hdo, and 
C              a set of 4 averaging kernels, this:
C              - interpolates model profiles onto the TES levels
C              - converts from mmr (spec hum) to vmr
C              - applies the TES avg krnl convolution 
C              - converts back to spec hum
C              - interpolates back to model levels
C********************************************************************** 
C 
C                               INPUT:
C

      USE MODEL_COM, only : lm
      USE CONSTANT, only : undef
      IMPLICIT NONE
!@var nPresTES number of TES pressure levels
      INTEGER, INTENT(IN) :: nPresTES
      REAL*8, INTENT(IN), DIMENSION(nPresTES) :: presTES
!@var h2oModelSH single model H2O profile on hybrid levels in kg/kg
!@var hdoModelSH single model HDO profile on hybrid levels in kg/kg
!@var presModel pressure at midpoint of box (i.e. from PMID)
      REAL*8, INTENT(IN), DIMENSION(LM)::h2oModelSH,hdoModelSH,presModel
!@var qPrior prior H2O profile on pressure levels
!@var rPrior prior HDO/H2O (volume) profile on pressure levels (invariant)
      REAL*8, INTENT(IN), DIMENSION(nPresTES) :: qPrior,rPrior
!@var dataLevIndTES indices in presTES over which avg krnls are applied
!@var tesAKIndTES indices presTES over which avg krnls are used
      INTEGER, INTENT(IN) :: nDataLev, nAKLev
      INTEGER, INTENT(IN), DIMENSION(nDataLev):: dataLevIndTES
      INTEGER, INTENT(IN), DIMENSION(nAKLev):: tesAKIndTES
!@var H2OAK single H2O averaging kernel
!@var HDOAK single HDO averaging kernel
!@var HDAK single HD averaging kernel
!@var DHAK single DH averaging kernel
      REAL*8, INTENT(IN), DIMENSION(nDataLev,nAKLev) :: H2OAK,HDOAK
      REAL*8, INTENT(IN), DIMENSION(nDataLev,nAKLev) :: HDAK,DHAK

C 
C                               OUTPUT:
C
!@var h2oModelNewSH convolved H2O profile
!@var hdoModelNewSH convolved H2O profile
!@var h2oModelIntpSH H2O profile, inteprolation only
!@var hdoModelIntpSH H2O profile, inteprolation only
!@var qPriorModLev qPrior on model levels
!@var maxSen peak sensitivity of HDO AK
!@var maxSenHt height (hPa) of peak sensitivity of HDO AK
      REAL*8,INTENT(OUT),DIMENSION(lm) :: h2oModelNewSH
      REAL*8,INTENT(OUT),DIMENSION(lm) :: hdoModelNewSH
      REAL*8,INTENT(OUT),DIMENSION(lm) :: h2oModelIntpSH
      REAL*8,INTENT(OUT),DIMENSION(lm) :: hdoModelIntpSH
      REAL*8,INTENT(OUT),DIMENSION(lm) :: qPriorModLev
      REAL*8,INTENT(OUT),DIMENSION(lm) :: maxSen,maxSenHt


C 
C                               INTERNAL VARIABLES
C
      REAL*8, DIMENSION(nPresTES) :: h2oModelTESsh,hdoModelTESsh
      REAL*8, DIMENSION(nPresTES) :: h2oModelTESvmr,hdoModelTESvmr
      REAL*8, DIMENSION(nPresTES) :: h2oPriorTESvmr,hdoPriorTESvmr	  
      REAL*8, DIMENSION(nDataLev) :: h2oNewShortvmr
      REAL*8, DIMENSION(nDataLev) :: hdoNewShortvmr
      REAL*8, DIMENSION(lm) :: dDNew,h2oNewModelvmr,hdoNewModelvmr
      REAL*8, DIMENSION(lm) :: h2oModelIntpvmr,hdoModelIntpvmr

      INTEGER :: maxSenI,currDatLev
      REAL*8, DIMENSION(nDataLev) :: maxSenTES, maxSenHtTES
      REAL*8, DIMENSION(nAKLev) :: AKrow

C molecular masses of dry air, h2o and hdo
C REALLY NEED TO ORGANIZE THESE CONSTANTS BETTER - THEY'RE EVERYWHERE
      REAL*8 :: Mdry,Mh2o,Mhdo
      REAL*8 :: SMOWMASS,SMOWVOL
      REAL*8, DIMENSION(nDataLev) :: dDVol,dDMass

      h2oModelNewSH(1:lm) = undef
      hdoModelNewSH(1:lm) = undef
      maxSen(1:lm) = undef
      maxSenHt(1:lm) = undef

C oxygen - 15.9994
C hydrogen - 1.00794
C deuterium - 	2.01410178
      Mdry=28.966               
      Mh2o=18.016
      Mhdo=19.11144178
      SMOWMASS=3.29d-4
      SMOWVOL =(Mh2o/Mhdo)*SMOWMASS

C**** Interpolate model profiles onto TES pressure levels
      CALL LINTERP(0,lm,presModel,h2oModelSH,
     &            nPresTES,presTES,h2oModelTESsh)
      CALL LINTERP(0,lm,presModel,hdoModelSH,
     &            nPresTES,presTES,hdoModelTESsh)

C**** Convert from spec hum to vmr
      CALL sh2vmr(nPresTES,h2oModelTESsh,hdoModelTESsh,
     &            h2oModelTESvmr,hdoModelTESvmr)

C**** The hdoPriorTESvmr provided to the call is a dummy variable      
      CALL sh2vmr(nPresTES,qPrior,undef*qPrior,
     &            h2oPriorTESvmr,hdoPriorTESvmr)
      hdoPriorTESvmr = rPrior*h2oPriorTESvmr

C****
C**** Apply averaging kernel convolution.
C**** This is what it's all about.
C****
      CALL ApplyTESAvgKrnls(nPresTES,presTES
     *     ,h2oModelTESvmr,hdoModelTESvmr
     *     ,H2OAK,HDOAK,HDAK,DHAK
     *     ,h2oPriorTESvmr,hdoPriorTESvmr
     *     ,nDataLev,nAKLev,dataLevIndTES,tesAKIndTES
     *     ,h2oNewShortvmr,hdoNewShortvmr)

C**** Interpolate back onto model levels, convert back to moist mmr
      CALL LINTERP(0,nDataLev,presTES(dataLevIndTES),h2oNewShortvmr,
     &                    lm,presModel,h2oNewModelvmr)
      CALL LINTERP(0,nDataLev,presTES(dataLevIndTES),hdoNewShortvmr,
     &                    lm,presModel,hdoNewModelvmr)
      CALL vmr2sh(lm,h2oNewModelvmr,hdoNewModelvmr,
     &            h2oModelNewSH,hdoModelNewSH)

C**** Same for profiles subject to interpolation only, no convolution	 
      CALL LINTERP(0,nPresTES,presTES,h2oModelTESvmr,
     &                    lm,presModel,h2oModelIntpvmr)
      CALL LINTERP(0,nPresTES,presTES,hdoModelTESvmr,
     &                    lm,presModel,hdoModelIntpvmr)
      CALL vmr2sh(lm,h2oModelIntpvmr,hdoModelIntpvmr,
     &            h2oModelIntpSH,hdoModelIntpSH)

C**** Also want qPrior on model levels for diagnostics
      CALL LINTERP(0,nPresTES,presTES,qPrior,
     &                    lm,presModel,qPriorModLev)

C****
C**** Also want max HDO sensitivity and its height for diagnostics
C****

C**** For each 'data' lev, find max sensitivity and its height
      DO currDatLev=1,nDataLev
         AKrow = HDOAK(currDatLev,:)
         maxSenI = maxloc(AKrow,1)
         IF (.NOT. ISNAN(HDOAK(currDatLev,maxSenI))) THEN
         maxSenTES(currDatLev) = HDOAK(currDatLev,maxSenI)
         maxSenHtTES(currDatLev)=presTES(tesAKIndTES(maxSenI) 
     *          + minval(tesAKIndTES)-1)
         ENDIF

      ENDDO

C**** Interpolate these back onto model levels
      CALL LINTERP(0,nDataLev,presTES(dataLevIndTES),maxSenTES,
     &                    lm,presModel,maxSen)
      CALL LINTERP(0,nDataLev,presTES(dataLevIndTES),maxSenHtTES,
     &                    lm,presModel,maxSenHt)

      END SUBROUTINE ApplyTESOperator
	  


      SUBROUTINE ApplyTESAvgKrnls(nPresTES,presTES,H2OModelv,HDOModelv
     *     ,H2OAK,HDOAK,HDAK,DHAK
     *     ,H2OPriorv,HDOPriorv
     *     ,nDataLev, nAKLev,dataLevIndTES,AKIndTES
     *     ,H2OModelNewv,HDOModelNewv)
C********************************************************************** 
C Description: Computes averaging kernel convolution, given raw model
C profiles of H2O and HDO, TES prior profiles of H2O and HDO, and a 
C set of four averaging kernels. All input profiles are on the TES
C pressure levels, and in volume mixing ratio. Based on code from
C Camille Risi.
C********************************************************************** 
      USE CONSTANT, only : undef
      IMPLICIT NONE
C 
C                               INPUT:
C
!@var presTES vector of full TES pressureLevels
      INTEGER, INTENT(IN) :: nPresTES
      REAL*8, INTENT(IN),DIMENSION(nPresTES) :: presTES
!@var H2OModelv original H2O profile (vmr) from model on TES levels
!@var HDOModelv original HDO profile (vmr) from model on TES levels
      REAL*8, INTENT(IN),DIMENSION(nPresTES) :: H2OModelv, HDOModelv
!@var H2OPriorv H2O prior (vmr) from TES file 
!@var HDOPriorv HDO prior(vmr) from TES file
      REAL*8, INTENT(IN),DIMENSION(nPresTES) :: H2OPriorv,HDOPriorv
!@var H2OAK averaging kernel 
!@var HDOAK averaging kernel 
!@var HDAK averaging kernel 
!@var DHAK averaging kernel 
      INTEGER, INTENT(IN) :: nDataLev, nAKLev
      REAL*8, INTENT(IN),DIMENSION(nDataLev,nAKLev) :: H2OAK,HDOAK
      REAL*8, INTENT(IN),DIMENSION(nDataLev,nAKLev) :: HDAK,DHAK
!@var dataLevIndTES TES data level indices
!@var AKIndTES TES avg krnl level indices
      INTEGER, INTENT(IN),DIMENSION(nDataLev) :: dataLevIndTES
      INTEGER, INTENT(IN),DIMENSION(nAKLev) :: AKIndTES
C 
C                               OUTPUT:
C
!@var newH2OProfile new model H2O profile (vmr) after avg krnl.
      REAL*8,INTENT(OUT),DIMENSION(nDataLev):: H2OModelNewv,HDOModelNewv
C 
C                         LOCAL VARIABLES
C

      REAL*8 RPrior,lnH2ONew,lnRNew,isoRatioNew
C      REAL*8, DIMENSION(nDataLev) :: H2OModelNewv, HDOModelNewv
      INTEGER dataLev,akLev,dataLevInd,akLevInd


      H2OModelNewv = undef
      HDOModelNewv = undef

C**** See L344-416 from Camille's 'program_apply_kernels_monthly'
      DO dataLev=1,nDataLev
          dataLevInd = dataLevIndTES(dataLev)
          IF (.NOT. ISNAN(H2OPriorv(dataLevInd))) THEN
          lnH2ONew = log(H2OPriorv(dataLevInd))
          DO akLev = 1,nAKLev
              akLevInd = AKIndTES(akLev)

	      IF ( (.NOT. ISNAN(H2OAK(dataLev,akLev))) .AND.
     &             (.NOT. ISNAN(H2OPriorv(akLevInd))) .AND.
     &             (H2OModelv(akLevInd).NE.undef)) THEN
	          lnH2ONew = lnH2ONew
     *            + H2OAK(dataLev,akLev)
     *            *(log(H2OModelv(akLevInd)) - log(H2OPriorv(akLevInd)))
              ENDIF  
          ENDDO
          H2OModelNewv(dataLev) = exp(lnH2ONew)
          ENDIF
      ENDDO

      DO dataLev=1,nDataLev
            dataLevInd = dataLevIndTES(dataLev)
            IF (.NOT. ISNAN(H2OPriorv(dataLevInd))) THEN
            lnRNew = log(HDOPriorv(dataLevInd)/H2OPriorv(dataLevInd))
            DO akLev = 1,nAKLev
                akLevInd = AKIndTES(akLev)
		IF ( (.NOT. ISNAN(H2OAK(dataLev,akLev))) .AND.
     &	             (.NOT. ISNAN(HDOAK(dataLev,akLev))) .AND.
     &	             (.NOT. ISNAN(HDAK(dataLev,akLev))) .AND.
     &	             (.NOT. ISNAN(DHAK(dataLev,akLev))) .AND.				 
     &	             (.NOT. ISNAN(H2OPriorv(akLevInd))) .AND.				 
     &	             (.NOT. ISNAN(HDOPriorv(akLevInd))) .AND.				 
     &	             (H2OModelv(akLevInd).NE.undef) .AND.
     &	             (HDOModelv(akLevInd).NE.undef)) THEN

		     lnRNew = lnRNew
     *          + (HDOAK(dataLev,akLev)-HDAK(dataLev,akLev))
     *          * (log(HDOModelv(akLevInd)) - log(HDOPriorv(akLevInd)))
     *          - (H2OAK(dataLev,akLev)-DHAK(dataLev,akLev))
     *          * (log(H2OModelv(akLevInd)) - log(H2OPriorv(akLevInd)))
		ENDIF  
            ENDDO
            isoRatioNew = exp(lnRNew)
            HDOModelNewv(dataLev) = isoRatioNew*H2OModelNewv(dataLev)
            ENDIF
      ENDDO

      END SUBROUTINE ApplyTESAvgKrnls

      SUBROUTINE LINTERP(ASCENDING,N,XI,FI,NNEW,XNEW,FNEW)
C
C     Linear interpolation. This could be more efficient...
C
C
      USE CONSTANT, only : undef
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: ASCENDING,N,NNEW
      REAL*8, INTENT(IN),DIMENSION(N) :: XI,FI
      REAL*8, INTENT(IN),DIMENSION(NNEW) :: XNEW
      REAL*8, INTENT(OUT),DIMENSION(NNEW) :: FNEW
      REAL*8 ratioPart
      INTEGER I,J

C****      print *,"XI",XI
C****      print *,"FI",FI
C****      print *,"XNEW",XNEW
	  
      DO I=1,NNEW-1
          FNEW(I) = undef
          DO J=1,N-1
              IF (XNEW(I).le.XI(J) .and. XNEW(I).ge.XI(J+1)) THEN
                  IF (FI(J).ne.undef .and. FI(J+1).ne.undef) THEN
                      ratioPart = (FI(J)-FI(J+1))/(XI(J) - XI(J+1))
                      FNEW(I)=FI(J+1) + (XNEW(I)-XI(J+1))*ratioPart
                  ENDIF
              ENDIF
          ENDDO
C****          print *,"FNEW(I)",FNEW(I)
      ENDDO

      END SUBROUTINE LINTERP

      SUBROUTINE sh2vmr(nLev,h2oSH,hdoSH,h2oVMR,hdoVMR)
C********************************************************************** 
C Description: Converts h2o and hdo from 'specific humidity' 
C (moist air mass mixing ratio) to volume mixing ratio.
C********************************************************************** 
      USE CONSTANT, only : undef
C 
C                               INPUT:
C
      INTEGER, INTENT(IN) :: nLev
!@var h2oSH h2o moist air mmr (spec hum)
!@var hdoSH hdo moist air mmr
      REAL*8, INTENT(IN),DIMENSION(nLev) :: h2oSH,hdoSH
C 
C                               OUTPUT:
C
!@var h2oVMR h2o volume mixing ratio
!@var hdoVMR h2o volume mixing ratio
      REAL*8, INTENT(OUT),DIMENSION(nLev) :: h2oVMR,hdoVMR
C 
C                               INTERNAL
C
c molecular masses of dry air, h2o and hdo
      REAL*8 :: Mdry,Mh2o,Mhdo
      INTEGER :: l

C oxygen - 15.9994
C hydrogen - 1.00794
C deuterium - 	2.01410178
      Mdry=28.966               
      Mh2o=18.016
      Mhdo=19.11144178

C These were derived starting from p32 of Jacobson
C "Fundamentals of atmospheric modeling"

      do  l=1,nLev
          if ((h2oSH(l).ne.undef).and.(hdoSH(l).ne.undef)) then
              h2oVMR(l) = (h2oSH(l)/(1.-h2oSH(l)))*(Mdry/Mh2o)
              hdoVMR(l) = (hdoSH(l)/Mhdo)*(Mh2o*h2oVMR(l) + Mdry)
          else
              h2oVMR(l) = undef
              hdoVMR(l) = undef
          endif
      enddo

      END SUBROUTINE sh2vmr

      SUBROUTINE vmr2sh(nLev,h2oVMR,hdoVMR,h2oSH,hdoSH)

      USE CONSTANT, only : undef
      INTEGER, INTENT(IN) :: nLev
      REAL*8, INTENT(IN),DIMENSION(nLev) :: h2oVMR,hdoVMR
      REAL*8, INTENT(OUT),DIMENSION(nLev) :: h2oSH,hdoSH
c molecular masses of dry air, h2o and hdo
      REAL*8 :: Mdry,Mh2o,Mhdo,mmr
C oxygen - 15.9994
C hydrogen - 1.00794
C deuterium - 	2.01410178
      Mdry=28.966
      Mh2o=18.016
      Mhdo=19.11144178

      do  l=1,nLev
          if ((h2oVMR(l).ne.undef) .and.
     &        (hdoVMR(l).ne.undef)) then
              mmr = h2oVMR(l)*(Mh2o/Mdry)
              h2oSH(l) = mmr/(1.+mmr)
              hdoSH(l) = (hdoVMR(l)*Mhdo)/
     *            (Mh2o*h2oVMR(l) + Mdry)
          else
              h2oSH(l) = undef
              hdoSH(l) = undef
          endif
      enddo
      END SUBROUTINE vmr2sh
	  
	  
	  
	  
      SUBROUTINE CalcPcpWat(nLevels,presLevs,q,srfDist,
     &                           pcpWLow,pcpWHigh)
C********************************************************************** 
C Description: Computes precipitable water given q on pressure levels, 
C              within srfDist hPa of surface, and above that.
C********************************************************************** 
      USE CONSTANT, only : undef,grav
      IMPLICIT NONE
C 
C                               INPUT:
C
!@var presLevs vector of pressure levels
!@var q specific humidity (kg/kg)
      INTEGER, INTENT(IN) :: nLevels
      REAL*8, INTENT(IN),DIMENSION(nLevels) :: presLevs,q
      REAL*8, INTENT(IN) :: srfDist

C
C                               OUTPUT:
C
!@var pcpWLow precipitable water over presLevs near surface
!@var pcpWHigh precipitable water in free atmosphere
      REAL*8,INTENT(OUT) :: pcpWLow,pcpWHigh
C 
C                         LOCAL VARIABLES
C
      REAL*8 :: minPres,maxPres,srfPres,bdyPres
      REAL*8, DIMENSION(nLevels) :: dstFrmGrnd
      INTEGER :: i,srfIndex,bdyIndex
      REAL*8, DIMENSION(nLevels) :: qFlip,presFlip

      REAL SplnCoeff(3,nLevels)
      REAL IntParts(nLevels)
      REAL Work(nLevels)

      pcpWLow = undef
      pcpWHigh = undef
      dstFrmGrnd = undef

C    Find index of surface, defined as first defined value 
C    of presLevs
      srfPres = undef
      srfIndex = 1
      do while (srfPres .eq. undef)
         if (presLevs(srfIndex) .ne. undef) then
             srfPres = presLevs(srfIndex)
         else
             srfIndex = srfIndex + 1
         endif
      enddo

C    make array containing the distance of each level to ground
      DO i=1,nLevels
          if (presLevs(i) .ne. undef) then
              dstFrmGrnd(i) = srfPres - presLevs(i)
          endif
      ENDDO

C    Find index of 'boundary layer' top
      bdyPres = 0.
      i = 1
      do while (bdyPres .eq. 0. .and. i.le.nLevels)
          if (dstFrmGrnd(i) .ge. srfDist) then
              bdyPres = presLevs(i)
              bdyIndex = i
          endif
          i = i + 1
      enddo
      
C      This could be more elegant using difference vectors
      pcpWLow = 0.
      DO i=1,bdyIndex-1
          pcpWLow = pcpWLow + (presLevs(i)-presLevs(i+1))*
     *        (q(i)+q(i+1))/2   
      ENDDO
      pcpWLow = 100*pcpWLow/grav

      pcpWHigh = 0.
      DO i=bdyIndex,nLevels-1
          pcpWHigh = pcpWHigh + (presLevs(i)-presLevs(i+1))*
     *        (q(i)+q(i+1))/2
      ENDDO
      pcpWHigh = 100*pcpWHigh/grav
      if (pcpWLow < 0 .or. pcpWHigh < 0) then
          print *,'pcpWLow',pcpWLow
          print *,'pcpWHigh',pcpWHigh
      endif


C    None of 3 canned numerical integration routines could handle profiles robustly.
C    Pre-Interpolating to a finer spacing might help, but for now, 
C    just use crude 'midpoint-rule type'appx integral above.
C
C	http://old.math.iastate.edu/burkardt/f_src/intlib/intlib.html

 
      END SUBROUTINE CalcPcpWat

